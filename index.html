<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Private Game Room</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
            display: flex;
        }

        .game-layout {
            display: flex;
            width: 100%;
            gap: 20px;
        }

        .scoreboard {
            width: 250px;
            flex-shrink: 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            height: fit-content;
            position: sticky;
            top: 20px;
        }

        .scoreboard h3 {
            text-align: center;
            color: #ff6b6b;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
        }

        .score-player {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-left: 3px solid transparent;
        }

        .score-player.host {
            border-left-color: #ff6b6b;
        }

        .score-player.czar {
            border-left-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
        }

        .score-player-name {
            font-weight: bold;
            font-size: 14px;
        }

        .score-player-points {
            color: #4ecdc4;
            font-weight: bold;
            font-size: 16px;
        }

        .main-content {
            flex: 1;
            min-width: 0;
        }

        .container {
            max-width: none;
            margin: 0;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: #ff6b6b;
        }

        .game-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .join-form {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .join-form input, .join-form button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
        }

        .join-form input {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            flex: 1;
            min-width: 200px;
        }

        .join-form input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .btn {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 16px;
        }

        .btn:hover {
            background: linear-gradient(135deg, #ee5a52, #ff6b6b);
            transform: translateY(-2px);
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #44a08d, #4ecdc4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545, #c82333);
        }

        .btn-danger:hover {
            background: linear-gradient(135deg, #c82333, #dc3545);
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107, #e0a800);
        }

        .btn-warning:hover {
            background: linear-gradient(135deg, #e0a800, #ffc107);
        }

        .game-info {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .game-code {
            font-size: 3rem;
            font-weight: bold;
            color: #4ecdc4;
            margin: 10px 0;
            letter-spacing: 8px;
            font-family: 'Courier New', monospace;
        }

        .players-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .player-card {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            padding: 15px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            position: relative;
        }

        .player-card.czar {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.2);
        }

        .player-card.host {
            border-color: #ff6b6b;
        }

        .player-name {
            font-weight: bold;
            font-size: 18px;
            margin-bottom: 5px;
        }

        .player-score {
            color: #4ecdc4;
            font-size: 24px;
            font-weight: bold;
        }

        .player-status {
            font-size: 0.9em;
            margin-top: 5px;
            padding: 4px 8px;
            border-radius: 4px;
            text-align: center;
        }

        .player-status.submitted {
            background: rgba(40, 167, 69, 0.3);
            color: #28a745;
        }

        .player-status.waiting {
            background: rgba(255, 193, 7, 0.3);
            color: #ffc107;
        }

        .black-card {
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 12px;
            padding: 20px;
            margin: 10px;
            font-size: 18px;
            font-weight: bold;
            min-height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .black-card:hover {
            border-color: #ff6b6b;
            transform: translateY(-2px);
        }

        .black-card.selected {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
        }

        .active-black-card {
            background: #1a1a1a;
            border: 2px solid #ffd700;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
            font-size: 20px;
            font-weight: bold;
            text-align: center;
            min-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .white-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .white-card {
            background: #f8f8f8;
            color: #333;
            border: 2px solid #ddd;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 16px;
        }

        .white-card:hover {
            border-color: #4ecdc4;
            transform: translateY(-2px);
        }

        .white-card.selected {
            border-color: #ff6b6b;
            background: #ffe6e6;
        }

        .custom-answer-input {
            width: 100%;
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 16px;
            margin-bottom: 10px;
        }

        .custom-answer-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .submissions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .submission-card {
            background: #f8f8f8;
            color: #333;
            border: 2px solid #ddd;
            border-radius: 10px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 16px;
        }

        .submission-card:hover {
            border-color: #4ecdc4;
            transform: translateY(-2px);
        }

        .submission-card.selected {
            border-color: #ff6b6b;
            background: #ffe6e6;
        }

        .submission-card.winner {
            border-color: #ffd700;
            background: #fffacd;
        }

        .actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .hidden {
            display: none;
        }

        .round-info {
            text-align: center;
            font-size: 20px;
            color: #4ecdc4;
            margin-bottom: 15px;
        }

        .game-status {
            text-align: center;
            font-size: 18px;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .waiting-indicator {
            text-align: center;
            padding: 20px;
            font-style: italic;
            color: #aaa;
        }

        .host-config {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .config-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .config-group label {
            font-weight: bold;
            color: #ff6b6b;
        }

        .config-group select {
            padding: 10px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
        }

        .removable-card {
            margin: 5px 0;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s ease;
            border-left: 3px solid transparent;
            position: relative;
        }

        .removable-card:hover {
            background: rgba(255, 99, 107, 0.3);
            border-left-color: #dc3545;
        }

        .submitted-answer {
            background: rgba(40, 167, 69, 0.2);
            border: 2px solid #28a745;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
        }

        .submitted-answer-text {
            font-size: 18px;
            font-weight: bold;
            color: #28a745;
            margin-bottom: 5px;
        }

        .all-submissions {
            margin-top: 30px;
        }

        .all-submissions h4 {
            color: #4ecdc4;
            margin-bottom: 15px;
            text-align: center;
        }

        .all-submissions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
        }

        .submission-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            font-size: 14px;
        }

        .submission-item.custom {
            border-left: 3px solid #ff6b6b;
        }

        .deck-stats {
            margin: 15px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            text-align: center;
        }

        .deck-stats h4 {
            color: #4ecdc4;
            margin-bottom: 5px;
        }

        .deck-management-actions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .textarea-container {
            position: relative;
            margin-bottom: 20px;
        }

        .textarea-container textarea {
            width: 100%;
            height: 150px;
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
            resize: vertical;
            font-family: Arial, sans-serif;
        }

        .textarea-container textarea::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .card-counter {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        .success-message {
            background: rgba(40, 167, 69, 0.2);
            border: 1px solid #28a745;
            color: #28a745;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
        }

        .error-message {
            background: rgba(220, 53, 69, 0.2);
            border: 1px solid #dc3545;
            color: #dc3545;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
        }

        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }
            
            .game-layout {
                flex-direction: column;
            }
            
            .scoreboard {
                width: 100%;
                position: static;
                order: -1;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .join-form {
                flex-direction: column;
            }
            
            .join-form input {
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <div class="game-layout">
        <!-- Scoreboard -->
        <div id="scoreboard" class="scoreboard hidden">
            <h3>🏆 Scoreboard</h3>
            <div id="scoreboardPlayers">
                <!-- Score list will be populated here -->
            </div>
        </div>

        <!-- Main Game Content -->
        <div class="main-content">
            <div class="container">
        <div class="header">
            <h1>🎲 Private Game Room</h1>
            <p>A card game for friends who aren't easily offended</p>
        </div>

        <!-- Start/Join Game Section -->
        <div id="mainSection" class="game-section">
            <h2 style="text-align: center; margin-bottom: 20px;">Join or Create Game</h2>
            <div class="join-form">
                <input type="text" id="playerName" placeholder="Enter your name" maxlength="20">
                <input type="text" id="gameCode" placeholder="Game code (leave empty to create)" maxlength="4">
                <button class="btn" onclick="joinOrCreateGame()">Join/Create Game</button>
            </div>
            
            <div class="actions" style="margin-top: 20px;">
                <button class="btn btn-secondary" onclick="showGlobalCardManagement()">Manage Global Card Decks</button>
            </div>
        </div>

        <!-- Game Info Section -->
        <div id="gameInfoSection" class="game-section hidden">
            <div class="game-info">
                <h3>Game Code:</h3>
                <div class="game-code" id="displayGameCode"></div>
                <p>Share this code with friends to let them join!</p>
            </div>
        </div>

        <!-- Players List -->
        <div id="playersSection" class="game-section hidden">
            <h2 style="text-align: center; margin-bottom: 20px;">Players</h2>
            <div id="playersList" class="players-list">
                <!-- Players will be populated here -->
            </div>
            <div id="hostControls" class="hidden">
                <h3 style="text-align: center; margin: 20px 0;">Game Settings</h3>
                <div class="host-config">
                    <div class="config-group">
                        <label for="hostWhiteCardCount">Cards per Player:</label>
                        <select id="hostWhiteCardCount">
                            <option value="5">5 Cards</option>
                            <option value="7" selected>7 Cards</option>
                            <option value="10">10 Cards</option>
                        </select>
                    </div>
                    <div class="config-group">
                        <label for="hostRoundCount">Number of Rounds:</label>
                        <select id="hostRoundCount">
                            <option value="5">5 Rounds</option>
                            <option value="10" selected>10 Rounds</option>
                            <option value="15">15 Rounds</option>
                            <option value="20">20 Rounds</option>
                        </select>
                    </div>
                </div>
                
                <div class="actions" style="margin-top: 15px;">
                    <button class="btn" onclick="startGame()">Start Game</button>
                </div>
            </div>
        </div>

        <!-- Global Card Management Modal -->
        <div id="globalCardManagementModal" class="game-section hidden" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000; max-height: 90vh; overflow-y: auto; width: 95%; max-width: 900px;">
            <h2 style="text-align: center; margin-bottom: 20px;">🎴 Manage Global Card Decks</h2>
            <p style="text-align: center; margin-bottom: 20px; color: #4ecdc4;">Changes made here will affect ALL future games</p>
            
            <div class="deck-management-actions">
                <button class="btn btn-secondary" onclick="switchCardType('black')">Edit Black Cards</button>
                <button class="btn btn-secondary" onclick="switchCardType('white')">Edit White Cards</button>
                <button class="btn btn-warning" onclick="resetToDefaults()">Reset to Defaults</button>
                <button class="btn" onclick="closeGlobalCardManagement()">Done</button>
            </div>

            <div id="deckStats" class="deck-stats">
                <!-- Deck statistics will be shown here -->
            </div>

            <div id="messageContainer">
                <!-- Success/error messages will appear here -->
            </div>
            
            <div class="textarea-container">
                <h4 id="globalCardTypeTitle">Add New Black Cards:</h4>
                <textarea id="globalBulkCardInput" placeholder="Paste cards here, one per line...&#10;&#10;Example:&#10;What's the next Happy Meal toy?&#10;___: kid tested, mother approved.&#10;I drink to forget ___."></textarea>
                <div class="card-counter" id="cardCounter">0 cards</div>
            </div>
            
            <div class="actions" style="margin-bottom: 20px;">
                <button class="btn btn-secondary" onclick="addGlobalBulkCards()">Add Cards to Global Deck</button>
                <button class="btn btn-danger" onclick="clearAllCards()">Clear All Cards of This Type</button>
            </div>
            
            <h4 style="margin: 20px 0;">Current Cards (click to remove):</h4>
            <div id="globalCurrentCardsList" style="max-height: 400px; overflow-y: auto; background: rgba(0,0,0,0.1); padding: 15px; border-radius: 10px;">
                <!-- Current cards will be listed here -->
            </div>
        </div>

        <!-- Game Status -->
        <div id="gameStatus" class="game-status hidden">
            Waiting for game to start...
        </div>

        <!-- Round Info -->
        <div id="roundInfo" class="round-info hidden">
            <!-- Round information will be displayed here -->
        </div>

        <!-- Czar Black Card Selection -->
        <div id="czarSection" class="game-section hidden">
            <h2 style="text-align: center; margin-bottom: 20px;">Choose a Black Card</h2>
            <div id="blackCardOptions" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px;">
                <!-- Black card options will be populated here -->
            </div>
            <div class="actions">
                <button class="btn btn-secondary" onclick="redrawBlackCards()">Redraw Cards</button>
                <button id="selectBlackCardBtn" class="btn" onclick="selectBlackCard()" disabled>Select This Card</button>
            </div>
        </div>

        <!-- Active Round -->
        <div id="roundSection" class="game-section hidden">
            <div id="activeBlackCard" class="active-black-card">
                <!-- Active black card will be displayed here -->
            </div>

            <!-- Player Hand -->
            <div id="playerHand">
                <h3 style="margin-bottom: 15px;">Your White Cards:</h3>
                <div id="whiteCards" class="white-cards">
                    <!-- Player's white cards will be populated here -->
                </div>
            </div>

            <!-- Custom Answer Section -->
            <div style="margin-bottom: 20px;">
                <h3 style="margin-bottom: 10px;">Or submit a custom answer:</h3>
                <input type="text" id="customAnswerInput" class="custom-answer-input" placeholder="Type your own hilarious answer..." maxlength="100">
            </div>

            <div class="actions">
                <button class="btn btn-secondary" onclick="redrawHand()">Redraw All Cards</button>
                <button id="submitAnswerBtn" class="btn" onclick="submitAnswer()" disabled>Submit Answer</button>
            </div>
        </div>

        <!-- Submissions and Judging -->
        <div id="submissionsSection" class="game-section hidden">
            <div id="activeBlackCardJudge" class="active-black-card">
                <!-- Active black card for judging will be displayed here -->
            </div>
            
            <div class="waiting-indicator" id="waitingIndicator">
                <!-- Waiting message will be shown here -->
            </div>

            <div>
                <h3 style="text-align: center; margin-bottom: 20px;">Submitted Answers</h3>
                <div id="submissionsGrid" class="submissions-grid">
                    <!-- Submitted answers will be populated here -->
                </div>
            </div>

            <div class="actions" id="judgeActions">
                <button id="selectWinnerBtn" class="btn" onclick="selectWinner()" disabled>Choose Winner</button>
            </div>
        </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK - Using different CDN for better compatibility -->
    <script src="https://cdn.jsdelivr.net/npm/firebase@9.22.0/compat/app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/firebase@9.22.0/compat/database.js"></script>

    <script>
        // Wait for Firebase to load before initializing
        window.addEventListener('load', function() {
            // Check if Firebase loaded successfully
            if (typeof firebase === 'undefined') {
                console.error('Firebase failed to load, falling back to local mode');
                initializeLocalMode();
                return;
            }

            try {
                // Firebase Configuration
                const firebaseConfig = {
                    apiKey: "AIzaSyA7hz07OZNNNLPKlQFw1j5vEiewwPOOUOQ",
                    authDomain: "saturday-night-cards.firebaseapp.com",
                    databaseURL: "https://saturday-night-cards-default-rtdb.firebaseio.com",
                    projectId: "saturday-night-cards",
                    storageBucket: "saturday-night-cards.firebasestorage.app",
                    messagingSenderId: "216085215949",
                    appId: "1:216085215949:web:1a08c0096000713518c784"
                };

                // Initialize Firebase
                firebase.initializeApp(firebaseConfig);
                window.database = firebase.database();
                console.log('Firebase initialized successfully');
                
                // Initialize the app
                initializeApp();
            } catch (error) {
                console.error('Firebase initialization failed:', error);
                initializeLocalMode();
            }
        });

        // Fallback to local mode if Firebase fails
        function initializeLocalMode() {
            console.log('Running in local mode - multiplayer features disabled');
            
            // Create mock database for local testing
            const mockDatabase = {
                data: {},
                
                setData: function(path, data) {
                    const keys = path.split('/');
                    let current = this.data;
                    
                    for (let i = 0; i < keys.length - 1; i++) {
                        if (!current[keys[i]]) current[keys[i]] = {};
                        current = current[keys[i]];
                    }
                    
                    current[keys[keys.length - 1]] = data;
                    
                    try {
                        localStorage.setItem('cardsGameData', JSON.stringify(this.data));
                    } catch (e) {
                        console.log('LocalStorage not available');
                    }
                },
                
                getData: function(path) {
                    try {
                        const stored = localStorage.getItem('cardsGameData');
                        if (stored) {
                            this.data = JSON.parse(stored);
                        }
                    } catch (e) {
                        console.log('LocalStorage not available');
                    }
                    
                    const keys = path.split('/');
                    let current = this.data;
                    
                    for (const key of keys) {
                        if (!current || !current[key]) return null;
                        current = current[key];
                    }
                    
                    return current;
                },
                
                ref: function(path) {
                    const self = this;
                    return {
                        set: async (data) => {
                            self.setData(path, data);
                            return Promise.resolve();
                        },
                        update: async (data) => {
                            const current = self.getData(path) || {};
                            self.setData(path, { ...current, ...data });
                            return Promise.resolve();
                        },
                        once: async (eventType) => {
                            const data = self.getData(path);
                            return Promise.resolve({
                                val: () => data,
                                exists: () => data !== null && data !== undefined
                            });
                        },
                        on: (eventType, callback) => {
                            const interval = setInterval(() => {
                                const data = self.getData(path);
                                callback({ val: () => data });
                            }, 1000);
                            return interval;
                        }
                    };
                }
            };

            window.database = mockDatabase;
            database = mockDatabase; // Set global variable
            initializeApp();
        }

        // Initialize app after database is ready
        function initializeApp() {
            updateGameStatus('Welcome! Enter your name to join or create a game.');
            initializeCardDecks();
        }

        // Make database globally accessible
        let database;

        // Global functions that need to be available immediately
        window.joinOrCreateGame = joinOrCreateGame;
        window.showGlobalCardManagement = showGlobalCardManagement;

        // Game state
        let currentGame = null;
        let currentPlayer = {
            id: null,
            name: '',
            isHost: false
        };
        let selectedCardIndex = null;
        let selectedSubmissionIndex = null;
        let globalCardType = 'black';

        // Default card decks
        const defaultBlackCards = [
            "___: kid tested, mother approved.",
            "___? There's an app for that.",
            "What's the next Happy Meal toy?",
            "In his new self-produced album, Kanye West raps over the sounds of ___.",
            "What ended my last relationship?",
            "I drink to forget ___.",
            "What's that sound?",
            "What's the most emo?",
            "Instead of coal, Santa now gives the bad children ___.",
            "What gives me uncontrollable gas?",
            "The Academy Award for ___ goes to ___.",
            "What's my secret power?",
            "___ + ___ = ___.",
            "In M. Night Shyamalan's new movie, Bruce Willis discovers that ___ had really been ___ all along.",
            "What's the new fad diet?",
            "What's there a ton of in heaven?",
            "Coming to Broadway this season, ___: The Musical.",
            "Alternative medicine is now embracing the curative powers of ___.",
            "What's Batman's guilty pleasure?",
            "TSA guidelines now prohibit ___ on airplanes."
        ];

        const defaultWhiteCards = [
            "A mime having a stroke",
            "The Big Bang",
            "Getting so angry you pop a boner",
            "Vigorous jazz hands",
            "A windmill full of corpses",
            "Swooping",
            "The invisible hand",
            "A sassy black woman",
            "Abstinence",
            "Adderall",
            "My genitals",
            "Racially-biased SAT questions",
            "The Three-Fifths compromise",
            "Take-backsies",
            "My collection of high-tech sex toys",
            "Throwing a virgin into a volcano",
            "Bling",
            "Poor life choices",
            "Powerful thighs",
            "The South",
            "Expecting a burp and vomiting on the floor",
            "Cheating in the Special Olympics",
            "My sex life",
            "Incest",
            "A can of whoop-ass",
            "Viagra",
            "Dead babies",
            "Switching to Geico",
            "Daniel Radcliffe's delicious asshole",
            "Erectile dysfunction"
        ];

        // Initialize persistent card decks
        async function initializeCardDecks() {
            const decksRef = database.ref('globalCardDecks');
            const snapshot = await decksRef.once('value');
            
            if (!snapshot.exists()) {
                // First time setup - save default decks
                await decksRef.set({
                    blackCards: defaultBlackCards,
                    whiteCards: defaultWhiteCards,
                    lastUpdated: Date.now(),
                    version: 1
                });
                console.log('Initialized default card decks');
            }
        }

        // Get current card decks from Firebase
        async function getCardDecks() {
            const snapshot = await database.ref('globalCardDecks').once('value');
            return snapshot.val() || {
                blackCards: defaultBlackCards,
                whiteCards: defaultWhiteCards
            };
        }

        // Update global card decks
        async function updateGlobalCardDecks(blackCards, whiteCards) {
            // Get current version number first
            const currentData = await getCardDecks();
            const currentVersion = currentData.version || 0;
            
            const updates = {
                blackCards: blackCards,
                whiteCards: whiteCards,
                lastUpdated: Date.now(),
                version: currentVersion + 1
            };
            
            await database.ref('globalCardDecks').update(updates);
            
            // Update all active games with new decks
            const gamesSnapshot = await database.ref('games').once('value');
            const games = gamesSnapshot.val();
            
            if (games) {
                const gameUpdates = {};
                Object.keys(games).forEach(gameCode => {
                    gameUpdates[`games/${gameCode}/blackCards`] = blackCards;
                    gameUpdates[`games/${gameCode}/whiteCards`] = whiteCards;
                });
                
                if (Object.keys(gameUpdates).length > 0) {
                    await database.ref().update(gameUpdates);
                    console.log(`Updated ${Object.keys(games).length} active games with new card decks`);
                }
            }
        }

        // Utility functions
        function generateId() {
            return Math.random().toString(36).substr(2, 9);
        }

        function generateGameCode() {
            return Math.floor(1000 + Math.random() * 9000).toString();
        }

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function getRandomCards(deck, count) {
            return shuffleArray(deck).slice(0, count);
        }

        function showMessage(message, type = 'success') {
            const container = document.getElementById('messageContainer');
            const messageDiv = document.createElement('div');
            messageDiv.className = type === 'success' ? 'success-message' : 'error-message';
            messageDiv.textContent = message;
            
            container.innerHTML = '';
            container.appendChild(messageDiv);
            
            setTimeout(() => {
                messageDiv.remove();
            }, 5000);
        }

        function updateCardCounter() {
            const textarea = document.getElementById('globalBulkCardInput');
            const counter = document.getElementById('cardCounter');
            const lines = textarea.value.split('\n').filter(line => line.trim()).length;
            counter.textContent = `${lines} card${lines !== 1 ? 's' : ''}`;
        }

        // UI Management
        function showSection(sectionId) {
            document.querySelectorAll('.game-section, #gameStatus, #roundInfo').forEach(section => {
                section.classList.add('hidden');
            });
            const section = document.getElementById(sectionId);
            if (section) section.classList.remove('hidden');
        }

        function updateGameStatus(message) {
            const statusEl = document.getElementById('gameStatus');
            statusEl.textContent = message;
            statusEl.classList.remove('hidden');
        }

        function updatePlayersDisplay(gameData) {
            const playersList = document.getElementById('playersList');
            playersList.innerHTML = '';

            if (!gameData.players) return;

            Object.values(gameData.players).forEach(player => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player-card';
                
                if (player.id === gameData.hostId) {
                    playerDiv.classList.add('host');
                }
                if (player.id === gameData.czarId) {
                    playerDiv.classList.add('czar');
                }

                let statusHtml = '';
                if (gameData.phase === 'players_submitting' && player.id !== gameData.czarId) {
                    const hasSubmitted = gameData.submittedPlayers && gameData.submittedPlayers[player.id];
                    statusHtml = `
                        <div class="player-status ${hasSubmitted ? 'submitted' : 'waiting'}">
                            ${hasSubmitted ? 'Submitted' : 'Thinking...'}
                        </div>
                    `;
                }

                playerDiv.innerHTML = `
                    <div class="player-name">
                        ${player.name}
                        ${player.id === gameData.hostId ? ' 👑' : ''}
                        ${player.id === gameData.czarId ? ' 🎩' : ''}
                    </div>
                    <div class="player-score">Score: ${player.score || 0}</div>
                    ${statusHtml}
                `;
                playersList.appendChild(playerDiv);
            });

            // Update scoreboard
            updateScoreboard(gameData);
        }

        function updateScoreboard(gameData) {
            const scoreboardContainer = document.getElementById('scoreboardPlayers');
            const scoreboard = document.getElementById('scoreboard');
            
            if (!gameData.players || gameData.phase === 'waiting') {
                scoreboard.classList.add('hidden');
                return;
            }

            // Show scoreboard during gameplay
            scoreboard.classList.remove('hidden');

            // Sort players by score (highest first)
            const sortedPlayers = Object.values(gameData.players).sort((a, b) => (b.score || 0) - (a.score || 0));

            scoreboardContainer.innerHTML = '';
            sortedPlayers.forEach((player, index) => {
                const scoreDiv = document.createElement('div');
                scoreDiv.className = 'score-player';
                
                if (player.id === gameData.hostId) {
                    scoreDiv.classList.add('host');
                }
                if (player.id === gameData.czarId) {
                    scoreDiv.classList.add('czar');
                }

                // Add rank indicator for top 3
                let rankIndicator = '';
                if (index === 0 && player.score > 0) rankIndicator = '🥇';
                else if (index === 1 && player.score > 0) rankIndicator = '🥈';
                else if (index === 2 && player.score > 0) rankIndicator = '🥉';

                scoreDiv.innerHTML = `
                    <div class="score-player-name">
                        ${rankIndicator} ${player.name}
                        ${player.id === gameData.hostId ? ' 👑' : ''}
                        ${player.id === gameData.czarId ? ' 🎩' : ''}
                    </div>
                    <div class="score-player-points">${player.score || 0}</div>
                `;
                scoreboardContainer.appendChild(scoreDiv);
            });
        }

        // Global Card Management Functions
        async function showGlobalCardManagement() {
            const overlay = document.createElement('div');
            overlay.className = 'overlay';
            overlay.onclick = closeGlobalCardManagement;
            document.body.appendChild(overlay);
            
            document.getElementById('globalCardManagementModal').classList.remove('hidden');
            await switchCardType('black');
            updateDeckStats();
        }

        function closeGlobalCardManagement() {
            document.getElementById('globalCardManagementModal').classList.add('hidden');
            const overlay = document.querySelector('.overlay');
            if (overlay) overlay.remove();
            document.getElementById('globalBulkCardInput').value = '';
            document.getElementById('messageContainer').innerHTML = '';
        }

        async function switchCardType(type) {
            globalCardType = type;
            document.getElementById('globalCardTypeTitle').textContent = 
                `Add New ${type.charAt(0).toUpperCase() + type.slice(1)} Cards:`;
            
            const textarea = document.getElementById('globalBulkCardInput');
            if (type === 'black') {
                textarea.placeholder = `Paste black cards here, one per line...

Example:
What's the next Happy Meal toy?
___: kid tested, mother approved.
I drink to forget ___.
___ + ___ = ___.`;
            } else {
                textarea.placeholder = `Paste white cards here, one per line...

Example:
A mime having a stroke
Vigorous jazz hands
My collection of high-tech sex toys
Poor life choices`;
            }
            
            await updateGlobalCurrentCardsList();
            updateDeckStats();
        }

        async function updateDeckStats() {
            const cardDecks = await getCardDecks();
            const blackCount = cardDecks.blackCards ? cardDecks.blackCards.length : 0;
            const whiteCount = cardDecks.whiteCards ? cardDecks.whiteCards.length : 0;
            
            document.getElementById('deckStats').innerHTML = `
                <h4>Current Deck Status</h4>
                <p>Black Cards: ${blackCount} | White Cards: ${whiteCount}</p>
                <p>Total Cards: ${blackCount + whiteCount}</p>
                <small>Last updated: ${cardDecks.lastUpdated ? new Date(cardDecks.lastUpdated).toLocaleDateString() : 'Never'}</small>
            `;
        }

        async function updateGlobalCurrentCardsList() {
            const cardDecks = await getCardDecks();
            const cards = globalCardType === 'black' ? cardDecks.blackCards : cardDecks.whiteCards;
            const listContainer = document.getElementById('globalCurrentCardsList');
            
            if (!cards || cards.length === 0) {
                listContainer.innerHTML = `<p style="text-align: center; color: #999; padding: 20px;">No ${globalCardType} cards found. Add some cards above!</p>`;
                return;
            }
            
            listContainer.innerHTML = cards.map((card, index) => 
                `<div class="removable-card" onclick="removeGlobalCard(${index})" title="Click to remove this card permanently">
                    <strong>${index + 1}.</strong> ${card}
                </div>`
            ).join('');
        }

        async function removeGlobalCard(index) {
            if (!confirm(`Remove this ${globalCardType} card permanently from all games?`)) return;

            try {
                const cardDecks = await getCardDecks();
                const cardArray = globalCardType === 'black' ? cardDecks.blackCards : cardDecks.whiteCards;
                
                if (!cardArray || index >= cardArray.length) {
                    showMessage('Card not found', 'error');
                    return;
                }
                
                const removedCard = cardArray[index];
                cardArray.splice(index, 1);
                
                // Update global decks
                await updateGlobalCardDecks(
                    globalCardType === 'black' ? cardArray : cardDecks.blackCards,
                    globalCardType === 'white' ? cardArray : cardDecks.whiteCards
                );
                
                showMessage(`"${removedCard}" removed from ${globalCardType} deck!`);
                await updateGlobalCurrentCardsList();
                updateDeckStats();
            } catch (error) {
                console.error('Error removing card:', error);
                showMessage('Error removing card: ' + error.message, 'error');
            }
        }

        async function addGlobalBulkCards() {
            const textarea = document.getElementById('globalBulkCardInput');
            const newCards = textarea.value.split('\n')
                .map(card => card.trim())
                .filter(card => card && card.length > 0);
            
            if (newCards.length === 0) {
                showMessage('Please enter some cards, one per line', 'error');
                return;
            }

            try {
                const cardDecks = await getCardDecks();
                const existingCards = globalCardType === 'black' ? (cardDecks.blackCards || []) : (cardDecks.whiteCards || []);
                
                // Check for duplicates
                const duplicates = newCards.filter(card => existingCards.includes(card));
                const uniqueNewCards = newCards.filter(card => !existingCards.includes(card));
                
                if (uniqueNewCards.length === 0) {
                    showMessage('All cards already exist in the deck', 'error');
                    return;
                }

                const combinedCards = [...existingCards, ...uniqueNewCards];

                // Update global decks
                await updateGlobalCardDecks(
                    globalCardType === 'black' ? combinedCards : (cardDecks.blackCards || []),
                    globalCardType === 'white' ? combinedCards : (cardDecks.whiteCards || [])
                );
                
                let message = `Successfully added ${uniqueNewCards.length} ${globalCardType} cards to global deck!`;
                if (duplicates.length > 0) {
                    message += ` (${duplicates.length} duplicates skipped)`;
                }
                
                showMessage(message);
                textarea.value = '';
                updateCardCounter();
                await updateGlobalCurrentCardsList();
                updateDeckStats();
            } catch (error) {
                console.error('Error adding cards:', error);
                showMessage('Error adding cards: ' + error.message, 'error');
            }
        }

        async function clearAllCards() {
            const cardType = globalCardType;
            if (!confirm(`Are you sure you want to clear ALL ${cardType} cards? This will affect all games and cannot be undone!`)) {
                return;
            }

            if (!confirm(`This will permanently delete all ${cardType} cards from the global deck. Are you absolutely sure?`)) {
                return;
            }

            try {
                const cardDecks = await getCardDecks();
                
                // Update global decks with empty array for the selected type
                await updateGlobalCardDecks(
                    cardType === 'black' ? [] : cardDecks.blackCards,
                    cardType === 'white' ? [] : cardDecks.whiteCards
                );
                
                showMessage(`All ${cardType} cards have been cleared from the global deck`);
                await updateGlobalCurrentCardsList();
                updateDeckStats();
            } catch (error) {
                console.error('Error clearing cards:', error);
                showMessage('Error clearing cards: ' + error.message, 'error');
            }
        }

        async function resetToDefaults() {
            if (!confirm('Reset card decks to default? This will replace all current cards with the original set.')) {
                return;
            }

            try {
                await updateGlobalCardDecks(defaultBlackCards, defaultWhiteCards);
                showMessage('Card decks reset to defaults!');
                await updateGlobalCurrentCardsList();
                updateDeckStats();
            } catch (error) {
                console.error('Error resetting cards:', error);
                showMessage('Error resetting cards: ' + error.message, 'error');
            }
        }

        // Game Logic
        async function joinOrCreateGame() {
            const nameInput = document.getElementById('playerName');
            const codeInput = document.getElementById('gameCode');
            const name = nameInput.value.trim();
            const code = codeInput.value.trim();

            if (!name) {
                alert('Please enter your name');
                return;
            }

            // Validate 4-digit code if provided
            if (code && (!/^\d{4}$/.test(code))) {
                alert('Game code must be exactly 4 digits');
                return;
            }

            currentPlayer.name = name;
            currentPlayer.id = generateId();

            if (code) {
                await joinGame(code);
            } else {
                await createGame();
            }
        }

        async function createGame() {
            const gameCode = generateGameCode();
            currentPlayer.isHost = true;

            // Get current card decks from persistent storage
            const cardDecks = await getCardDecks();

            const gameData = {
                code: gameCode,
                hostId: currentPlayer.id,
                phase: 'waiting',
                players: {
                    [currentPlayer.id]: {
                        id: currentPlayer.id,
                        name: currentPlayer.name,
                        score: 0,
                        hand: []
                    }
                },
                blackCards: cardDecks.blackCards,
                whiteCards: cardDecks.whiteCards,
                round: 0,
                maxRounds: 10,
                whiteCardCount: 7,
                createdAt: Date.now()
            };

            try {
                await database.ref(`games/${gameCode}`).set(gameData);
                currentGame = gameCode;
                setupGameListener(gameCode);
                showGameLobby(gameCode);
            } catch (error) {
                alert('Error creating game: ' + error.message);
            }
        }

        async function joinGame(gameCode) {
            try {
                const gameSnapshot = await database.ref(`games/${gameCode}`).once('value');
                const gameData = gameSnapshot.val();

                if (!gameData) {
                    alert('Game not found. Please check the code.');
                    return;
                }

                if (gameData.phase !== 'waiting') {
                    // Check if this player was already in the game (reconnection)
                    const existingPlayer = Object.values(gameData.players || {}).find(
                        player => player.name === currentPlayer.name
                    );
                    
                    if (existingPlayer) {
                        // Reconnect with same ID and score
                        currentPlayer.id = existingPlayer.id;
                        currentGame = gameCode;
                        setupGameListener(gameCode);
                        showGameLobby(gameCode);
                        return;
                    } else {
                        alert('This game has already started and you were not a participant.');
                        return;
                    }
                }

                await database.ref(`games/${gameCode}/players/${currentPlayer.id}`).set({
                    id: currentPlayer.id,
                    name: currentPlayer.name,
                    score: 0,
                    hand: []
                });

                currentGame = gameCode;
                setupGameListener(gameCode);
                showGameLobby(gameCode);
            } catch (error) {
                alert('Error joining game: ' + error.message);
            }
        }

        function setupGameListener(gameCode) {
            database.ref(`games/${gameCode}`).on('value', (snapshot) => {
                const gameData = snapshot.val();
                if (!gameData) return;
                updateGameDisplay(gameData);
            });
        }

        function updateGameDisplay(gameData) {
            updatePlayersDisplay(gameData);

            switch (gameData.phase) {
                case 'waiting':
                    showWaitingPhase(gameData);
                    break;
                case 'czar_selecting':
                    showCzarSelectionPhase(gameData);
                    break;
                case 'players_submitting':
                    showPlayerSubmissionPhase(gameData);
                    break;
                case 'judging':
                    showJudgingPhase(gameData);
                    break;
                case 'round_end':
                    showRoundEndPhase(gameData);
                    break;
                case 'game_end':
                    showGameEndPhase(gameData);
                    break;
            }
        }

        function showGameLobby(gameCode) {
            document.getElementById('displayGameCode').textContent = gameCode;
            document.getElementById('mainSection').classList.add('hidden');
            document.getElementById('gameInfoSection').classList.remove('hidden');
            document.getElementById('playersSection').classList.remove('hidden');
            
            if (currentPlayer.isHost) {
                document.getElementById('hostControls').classList.remove('hidden');
            }
        }

        function showWaitingPhase(gameData) {
            updateGameStatus('Waiting for players to join...');
        }

        async function startGame() {
            if (!currentPlayer.isHost) return;

            const gameData = (await database.ref(`games/${currentGame}`).once('value')).val();
            const playerCount = Object.keys(gameData.players).length;

            if (playerCount < 3) {
                alert('Need at least 3 players to start');
                return;
            }

            const whiteCardCount = parseInt(document.getElementById('hostWhiteCardCount').value);
            const roundCount = parseInt(document.getElementById('hostRoundCount').value);

            const updates = {};
            const playerIds = Object.keys(gameData.players);
            
            playerIds.forEach(playerId => {
                const hand = getRandomCards(gameData.whiteCards, whiteCardCount);
                updates[`players/${playerId}/hand`] = hand;
            });

            updates.phase = 'czar_selecting';
            updates.round = 1;
            updates.maxRounds = roundCount;
            updates.whiteCardCount = whiteCardCount;
            updates.czarId = gameData.hostId;
            updates.blackCardOptions = getRandomCards(gameData.blackCards, 3);

            await database.ref(`games/${currentGame}`).update(updates);
        }

        function showCzarSelectionPhase(gameData) {
            document.getElementById('hostControls').classList.add('hidden');
            updateGameStatus(`Round ${gameData.round} of ${gameData.maxRounds}`);
            
            const roundInfoEl = document.getElementById('roundInfo');
            const czar = gameData.players[gameData.czarId];
            roundInfoEl.innerHTML = `Card Czar: ${czar ? czar.name : 'Unknown'}`;
            roundInfoEl.classList.remove('hidden');

            if (currentPlayer.id === gameData.czarId) {
                showSection('czarSection');
                displayBlackCardOptions(gameData.blackCardOptions);
                updateGameStatus('You are the Card Czar! Choose a black card.');
            } else {
                updateGameStatus('Waiting for Card Czar to select a black card...');
            }
        }

        function displayBlackCardOptions(options) {
            const container = document.getElementById('blackCardOptions');
            container.innerHTML = '';

            options.forEach((card, index) => {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'black-card';
                cardDiv.textContent = card;
                cardDiv.onclick = () => selectBlackCardOption(index);
                container.appendChild(cardDiv);
            });
        }

        function selectBlackCardOption(index) {
            selectedCardIndex = index;
            
            document.querySelectorAll('#blackCardOptions .black-card').forEach((card, i) => {
                card.classList.toggle('selected', i === index);
            });
            
            document.getElementById('selectBlackCardBtn').disabled = false;
        }

        async function redrawBlackCards() {
            if (currentPlayer.id !== (await getCurrentGameData()).czarId) return;

            const gameData = await getCurrentGameData();
            const newOptions = getRandomCards(gameData.blackCards, 3);
            
            await database.ref(`games/${currentGame}/blackCardOptions`).set(newOptions);
        }

        async function selectBlackCard() {
            if (selectedCardIndex === null) return;

            const gameData = await getCurrentGameData();
            const selectedCard = gameData.blackCardOptions[selectedCardIndex];

            const updates = {
                phase: 'players_submitting',
                activeBlackCard: selectedCard,
                submissions: {},
                submittedPlayers: {}
            };

            await database.ref(`games/${currentGame}`).update(updates);
        }

        function showPlayerSubmissionPhase(gameData) {
            document.getElementById('activeBlackCard').textContent = gameData.activeBlackCard;
            document.getElementById('activeBlackCardJudge').textContent = gameData.activeBlackCard;

            if (currentPlayer.id === gameData.czarId) {
                showSection('submissionsSection');
                updateWaitingIndicator(gameData);
                updateSubmissionsDisplay(gameData);
                updateGameStatus('Waiting for players to submit their answers...');
            } else {
                // Check if player has already submitted
                const hasSubmitted = gameData.submittedPlayers && gameData.submittedPlayers[currentPlayer.id];
                
                if (hasSubmitted) {
                    // Show what they submitted
                    showSection('submissionsSection');
                    displayPlayerSubmission(gameData);
                    updateWaitingIndicator(gameData);
                    updateGameStatus('Answer submitted! Waiting for other players...');
                } else {
                    // Show submission interface
                    showSection('roundSection');
                    displayPlayerHand(gameData.players[currentPlayer.id].hand);
                    updateGameStatus('Choose a white card or type a custom answer, then submit!');
                }
            }
        }

        function displayPlayerSubmission(gameData) {
            const submissionsGrid = document.getElementById('submissionsGrid');
            submissionsGrid.innerHTML = '';

            // Find what this player submitted
            const playerSubmission = Object.values(gameData.submissions || {}).find(
                sub => sub.playerId === currentPlayer.id
            );

            if (playerSubmission) {
                const submittedDiv = document.createElement('div');
                submittedDiv.className = 'submitted-answer';
                submittedDiv.innerHTML = `
                    <div class="submitted-answer-text">Your Submission:</div>
                    <div>"${playerSubmission.answer}"</div>
                    ${playerSubmission.isCustom ? '<small>(Custom Answer)</small>' : ''}
                `;
                submissionsGrid.appendChild(submittedDiv);
            }

            // Show all submissions if everyone has submitted
            const playerIds = Object.keys(gameData.players).filter(id => id !== gameData.czarId);
            const submittedIds = Object.keys(gameData.submittedPlayers || {});
            
            if (playerIds.length === submittedIds.length && gameData.submissions) {
                const allSubmissionsDiv = document.createElement('div');
                allSubmissionsDiv.className = 'all-submissions';
                allSubmissionsDiv.innerHTML = '<h4>All Submitted Answers:</h4>';
                
                const gridDiv = document.createElement('div');
                gridDiv.className = 'all-submissions-grid';
                
                Object.values(gameData.submissions).forEach(submission => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'submission-item';
                    if (submission.isCustom) itemDiv.classList.add('custom');
                    itemDiv.textContent = `"${submission.answer}"`;
                    gridDiv.appendChild(itemDiv);
                });
                
                allSubmissionsDiv.appendChild(gridDiv);
                submissionsGrid.appendChild(allSubmissionsDiv);
            }
        }

        function displayPlayerHand(hand) {
            const container = document.getElementById('whiteCards');
            container.innerHTML = '';

            hand.forEach((card, index) => {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'white-card';
                cardDiv.textContent = card;
                cardDiv.onclick = () => selectWhiteCard(index);
                container.appendChild(cardDiv);
            });

            updateSubmitButton();
        }

        function selectWhiteCard(index) {
            selectedCardIndex = index;
            
            document.querySelectorAll('#whiteCards .white-card').forEach((card, i) => {
                card.classList.toggle('selected', i === index);
            });
            
            document.getElementById('customAnswerInput').value = '';
            updateSubmitButton();
        }

        function updateSubmitButton() {
            const customAnswer = document.getElementById('customAnswerInput').value.trim();
            const hasSelection = selectedCardIndex !== null || customAnswer;
            document.getElementById('submitAnswerBtn').disabled = !hasSelection;
        }

        async function submitAnswer() {
            const customAnswer = document.getElementById('customAnswerInput').value.trim();
            let answer;
            let isCustom = false;

            if (customAnswer) {
                answer = customAnswer;
                isCustom = true;
            } else if (selectedCardIndex !== null) {
                const gameData = await getCurrentGameData();
                const playerHand = gameData.players[currentPlayer.id].hand;
                answer = playerHand[selectedCardIndex];
                
                const newHand = [...playerHand];
                newHand.splice(selectedCardIndex, 1);
                const availableCards = gameData.whiteCards.filter(card => !newHand.includes(card));
                if (availableCards.length > 0) {
                    newHand.push(getRandomCards(availableCards, 1)[0]);
                }
                
                await database.ref(`games/${currentGame}/players/${currentPlayer.id}/hand`).set(newHand);
            } else {
                return;
            }

            const submissionId = generateId();
            const updates = {};
            updates[`submissions/${submissionId}`] = {
                playerId: currentPlayer.id,
                answer: answer,
                isCustom: isCustom
            };
            updates[`submittedPlayers/${currentPlayer.id}`] = true;

            await database.ref(`games/${currentGame}`).update(updates);

            selectedCardIndex = null;
            document.getElementById('customAnswerInput').value = '';
            updateGameStatus('Answer submitted! Waiting for other players...');

            checkAllSubmitted();
        }

        async function checkAllSubmitted() {
            const gameData = await getCurrentGameData();
            const playerIds = Object.keys(gameData.players).filter(id => id !== gameData.czarId);
            const submittedIds = Object.keys(gameData.submittedPlayers || {});

            if (playerIds.length === submittedIds.length) {
                await database.ref(`games/${currentGame}/phase`).set('judging');
            }
        }

        function showJudgingPhase(gameData) {
            showSection('submissionsSection');
            updateSubmissionsDisplay(gameData);
            
            if (currentPlayer.id === gameData.czarId) {
                updateGameStatus('Choose the winning answer!');
                document.getElementById('judgeActions').style.display = 'flex';
            } else {
                // Show what the player submitted during judging
                displayPlayerSubmission(gameData);
                updateGameStatus('Card Czar is choosing the winner...');
                document.getElementById('judgeActions').style.display = 'none';
            }
        }

        function updateSubmissionsDisplay(gameData) {
            const container = document.getElementById('submissionsGrid');
            container.innerHTML = '';

            if (!gameData.submissions) return;

            const submissions = Object.values(gameData.submissions);
            const shuffledSubmissions = shuffleArray(submissions);

            shuffledSubmissions.forEach((submission, index) => {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'submission-card';
                cardDiv.textContent = submission.answer;
                
                if (currentPlayer.id === gameData.czarId) {
                    cardDiv.onclick = () => selectSubmission(index, submission);
                }
                
                container.appendChild(cardDiv);
            });
        }

        function selectSubmission(index, submission) {
            selectedSubmissionIndex = index;
            
            document.querySelectorAll('#submissionsGrid .submission-card').forEach((card, i) => {
                card.classList.toggle('selected', i === index);
            });
            
            document.getElementById('selectWinnerBtn').disabled = false;
            window.selectedSubmission = submission;
        }

        async function selectWinner() {
            if (!window.selectedSubmission) return;

            const gameData = await getCurrentGameData();
            const winner = gameData.players[window.selectedSubmission.playerId];
            
            if (winner) {
                const updates = {
                    phase: 'round_end',
                    lastWinner: {
                        playerId: winner.id,
                        name: winner.name,
                        answer: window.selectedSubmission.answer
                    }
                };
                
                updates[`players/${winner.id}/score`] = (winner.score || 0) + 1;

                await database.ref(`games/${currentGame}`).update(updates);
            }
        }

        function showRoundEndPhase(gameData) {
            if (gameData.lastWinner) {
                updateGameStatus(`🎉 ${gameData.lastWinner.name} wins this round with: "${gameData.lastWinner.answer}"`);
                
                document.querySelectorAll('#submissionsGrid .submission-card').forEach(card => {
                    if (card.textContent === gameData.lastWinner.answer) {
                        card.classList.add('winner');
                    }
                });
            }

            setTimeout(() => {
                nextRound();
            }, 3000);
        }

        async function nextRound() {
            if (!currentPlayer.isHost) return;

            const gameData = await getCurrentGameData();
            const newRound = gameData.round + 1;

            if (newRound > gameData.maxRounds) {
                await database.ref(`games/${currentGame}/phase`).set('game_end');
                return;
            }

            const updates = {
                phase: 'czar_selecting',
                round: newRound,
                czarId: gameData.lastWinner ? gameData.lastWinner.playerId : gameData.hostId,
                blackCardOptions: getRandomCards(gameData.blackCards, 3),
                activeBlackCard: null,
                submissions: null,
                submittedPlayers: null,
                lastWinner: null
            };

            await database.ref(`games/${currentGame}`).update(updates);
        }

        function showGameEndPhase(gameData) {
            const players = Object.values(gameData.players);
            const maxScore = Math.max(...players.map(p => p.score || 0));
            const winners = players.filter(p => (p.score || 0) === maxScore);
            
            let message;
            if (winners.length === 1) {
                message = `🏆 Game Over! ${winners[0].name} wins with ${maxScore} points!`;
            } else {
                const winnerNames = winners.map(w => w.name).join(' and ');
                message = `🏆 Game Over! It's a tie between ${winnerNames} with ${maxScore} points each!`;
            }
            
            updateGameStatus(message);
            document.getElementById('roundInfo').classList.add('hidden');
        }

        function updateWaitingIndicator(gameData) {
            const indicator = document.getElementById('waitingIndicator');
            const playerIds = Object.keys(gameData.players).filter(id => id !== gameData.czarId);
            const submittedIds = Object.keys(gameData.submittedPlayers || {});
            const pendingIds = playerIds.filter(id => !submittedIds.includes(id));
            
            if (pendingIds.length > 0) {
                const pendingNames = pendingIds.map(id => gameData.players[id].name);
                indicator.textContent = `Waiting for: ${pendingNames.join(', ')}`;
                indicator.style.display = 'block';
            } else {
                indicator.style.display = 'none';
            }
        }

        async function redrawHand() {
            const gameData = await getCurrentGameData();
            const newHand = getRandomCards(gameData.whiteCards, gameData.whiteCardCount);
            
            await database.ref(`games/${currentGame}/players/${currentPlayer.id}/hand`).set(newHand);
        }

        async function getCurrentGameData() {
            const snapshot = await database.ref(`games/${currentGame}`).once('value');
            return snapshot.val();
        }

        // Event Listeners
        document.getElementById('playerName').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                joinOrCreateGame();
            }
        });

        document.getElementById('gameCode').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                joinOrCreateGame();
            }
        });

        document.getElementById('customAnswerInput').addEventListener('input', function(e) {
            selectedCardIndex = null;
            document.querySelectorAll('#whiteCards .white-card').forEach(card => {
                card.classList.remove('selected');
            });
            updateSubmitButton();
        });

        document.getElementById('customAnswerInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !document.getElementById('submitAnswerBtn').disabled) {
                submitAnswer();
            }
        });

        document.getElementById('globalBulkCardInput').addEventListener('input', updateCardCounter);

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Make all functions globally accessible for HTML onclick handlers
            window.joinOrCreateGame = joinOrCreateGame;
            window.showGlobalCardManagement = showGlobalCardManagement;
            window.closeGlobalCardManagement = closeGlobalCardManagement;
            window.switchCardType = switchCardType;
            window.resetToDefaults = resetToDefaults;
            window.addGlobalBulkCards = addGlobalBulkCards;
            window.clearAllCards = clearAllCards;
            window.removeGlobalCard = removeGlobalCard;
            window.startGame = startGame;
            window.showCardManagement = showCardManagement;
            window.closeCardManagement = closeCardManagement;
            window.selectBlackCardOption = selectBlackCardOption;
            window.redrawBlackCards = redrawBlackCards;
            window.selectBlackCard = selectBlackCard;
            window.selectWhiteCard = selectWhiteCard;
            window.submitAnswer = submitAnswer;
            window.redrawHand = redrawHand;
            window.selectSubmission = selectSubmission;
            window.selectWinner = selectWinner;
            
            // Initialization will be handled by the window load event
            // to ensure Firebase is loaded first
        });
    </script>
</body>
</html>
