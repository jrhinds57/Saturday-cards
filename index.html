<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Private Game Room</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
            display: flex;
        }

        .game-layout {
            display: flex;
            width: 100%;
            gap: 20px;
        }

        .scoreboard {
            width: 250px;
            flex-shrink: 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            height: fit-content;
            position: sticky;
            top: 20px;
        }

        .scoreboard h3 {
            text-align: center;
            color: #ff6b6b;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
        }

        .score-player {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-left: 3px solid transparent;
        }

        .score-player.host {
            border-left-color: #ff6b6b;
        }

        .score-player.czar {
            border-left-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
        }

        .score-player-name {
            font-weight: bold;
            font-size: 14px;
        }

        .score-player-points {
            color: #4ecdc4;
            font-weight: bold;
            font-size: 16px;
        }

        .main-content {
            flex: 1;
            min-width: 0;
        }

        .container {
            max-width: none;
            margin: 0;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: #ff6b6b;
        }

        .game-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .join-form {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .join-form input, .join-form button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
        }

        .join-form input {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            flex: 1;
            min-width: 200px;
        }

        .join-form input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .btn {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 16px;
        }

        .btn:hover {
            background: linear-gradient(135deg, #ee5a52, #ff6b6b);
            transform: translateY(-2px);
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #44a08d, #4ecdc4);
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 14px;
        }

        .game-info {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .game-code {
            font-size: 3rem;
            font-weight: bold;
            color: #4ecdc4;
            margin: 10px 0;
            letter-spacing: 8px;
            font-family: 'Courier New', monospace;
        }

        .players-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .player-card {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            padding: 15px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            position: relative;
        }

        .player-card.czar {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.2);
        }

        .player-card.host {
            border-color: #ff6b6b;
        }

        .player-name {
            font-weight: bold;
            font-size: 18px;
            margin-bottom: 5px;
        }

        .player-score {
            color: #4ecdc4;
            font-size: 24px;
            font-weight: bold;
        }

        .hidden {
            display: none;
        }

        .game-status {
            text-align: center;
            font-size: 18px;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .success-message {
            background: rgba(40, 167, 69, 0.2);
            border: 1px solid #28a745;
            color: #28a745;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 300px;
        }

        .error-message {
            background: rgba(220, 53, 69, 0.2);
            border: 1px solid #dc3545;
            color: #dc3545;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 300px;
        }

        .actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .card-customization {
            margin-bottom: 20px;
        }

        .card-customization h3 {
            text-align: center;
            color: #4ecdc4;
            margin-bottom: 15px;
        }

        .card-sections {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .card-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
        }

        .card-section h4 {
            color: #ff6b6b;
            margin-bottom: 10px;
            text-align: center;
        }

        .card-section textarea {
            width: 100%;
            height: 150px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: white;
            padding: 10px;
            font-size: 14px;
            resize: vertical;
        }

        .card-section textarea::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .card-help {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 5px;
        }

        .black-card {
            background: rgba(50, 50, 50, 0.8);
            border: 2px solid #444;
            border-radius: 10px;
            padding: 20px;
            margin: 10px 0;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
        }

        .white-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }

        .white-card {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .white-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .white-card.selected {
            border-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.2);
            color: white;
        }

        .round-info {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid #ffd700;
            border-radius: 10px;
            color: #ffd700;
        }

        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }
            
            .game-layout {
                flex-direction: column;
            }
            
            .scoreboard {
                width: 100%;
                position: static;
                order: -1;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .join-form {
                flex-direction: column;
            }
            
            .join-form input {
                min-width: auto;
            }

            .card-sections {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="game-layout">
        <!-- Scoreboard -->
        <div id="scoreboard" class="scoreboard hidden">
            <h3>Scoreboard</h3>
            <div id="scoreboardPlayers">
                <!-- Score list will be populated here -->
            </div>
        </div>

        <!-- Main Game Content -->
        <div class="main-content">
            <div class="container">
                <div class="header">
                    <h1>Private Game Room</h1>
                    <p>A card game for friends who aren't easily offended</p>
                </div>

                <!-- Start/Join Game Section -->
                <div id="mainSection" class="game-section">
                    <h2 style="text-align: center; margin-bottom: 20px;">Join or Create Game</h2>
                    <div class="join-form">
                        <input type="text" id="playerName" placeholder="Enter your name" maxlength="20">
                        <input type="text" id="gameCode" placeholder="Game code (leave empty to create)" maxlength="4">
                        <button class="btn" onclick="joinOrCreateGame()">Join/Create Game</button>
                    </div>
                </div>

                <!-- Game Info Section -->
                <div id="gameInfoSection" class="game-section hidden">
                    <div class="game-info">
                        <h3>Game Code:</h3>
                        <div class="game-code" id="displayGameCode"></div>
                        <p>Share this code with friends to let them join!</p>
                    </div>
                </div>

                <!-- Card Customization Section -->
                <div id="cardCustomization" class="game-section hidden">
                    <div class="card-customization">
                        <h3>Customize Game Settings</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                            <div>
                                <label style="display: block; margin-bottom: 5px; color: #4ecdc4;">Number of Rounds:</label>
                                <input type="number" id="maxRoundsInput" min="1" max="50" value="10" style="width: 100%; padding: 8px; border-radius: 5px; border: 1px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.1); color: white;">
                            </div>
                            <div>
                                <label style="display: block; margin-bottom: 5px; color: #4ecdc4;">Cards per Player:</label>
                                <input type="number" id="cardsPerPlayerInput" min="5" max="15" value="7" style="width: 100%; padding: 8px; border-radius: 5px; border: 1px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.1); color: white;">
                            </div>
                        </div>
                        <div class="card-sections">
                            <div class="card-section">
                                <h4>Black Cards (Questions)</h4>
                                <textarea id="blackCardsInput" placeholder="Enter one card per line. Use ___ for blanks.&#10;Example:&#10;What's my secret power?&#10;___ + ___ = ___."></textarea>
                                <div class="card-help">One card per line. Use ___ for blanks that players fill in.</div>
                            </div>
                            <div class="card-section">
                                <h4>White Cards (Answers)</h4>
                                <textarea id="whiteCardsInput" placeholder="Enter one card per line.&#10;Example:&#10;A mime having a stroke&#10;My genitals&#10;Poor life choices"></textarea>
                                <div class="card-help">One card per line. These are the answer options for players.</div>
                            </div>
                        </div>
                        <div class="actions" style="margin-top: 15px;">
                            <button class="btn btn-secondary btn-small" onclick="loadDefaultCards()">Reset to Defaults</button>
                            <button class="btn btn-small" onclick="updateCards()">Update Cards</button>
                        </div>
                    </div>
                </div>

                <!-- Players List -->
                <div id="playersSection" class="game-section hidden">
                    <h2 style="text-align: center; margin-bottom: 20px;">Players</h2>
                    <div id="playersList" class="players-list">
                        <!-- Players will be populated here -->
                    </div>
                    <div id="hostControls" class="hidden">
                        <div class="actions" style="margin-top: 15px;">
                            <button class="btn btn-secondary" onclick="refreshGameData()">Refresh Player List</button>
                            <button class="btn" onclick="startGame()">Start Game</button>
                            <button class="btn btn-secondary btn-small" onclick="showKickMenu()">Kick Player</button>
                        </div>
                    </div>

                    <!-- Kick Player Menu -->
                    <div id="kickPlayerMenu" class="hidden" style="margin-top: 15px; padding: 15px; background: rgba(220, 53, 69, 0.1); border: 1px solid #dc3545; border-radius: 8px;">
                        <h4 style="color: #dc3545; margin-bottom: 10px;">Remove Player</h4>
                        <select id="playerToKick" style="width: 100%; padding: 8px; margin-bottom: 10px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 5px;">
                            <option value="">Select player to remove...</option>
                        </select>
                        <div class="actions">
                            <button class="btn btn-small" onclick="kickPlayer()" style="background: #dc3545;">Remove Player</button>
                            <button class="btn btn-secondary btn-small" onclick="hideKickMenu()">Cancel</button>
                        </div>
                    </div>
                </div>

                <!-- Game Play Section -->
                <div id="gamePlaySection" class="game-section hidden">
                    <div id="roundInfo" class="round-info">
                        <h3>Round <span id="currentRound">1</span> of <span id="maxRounds">10</span></h3>
                        <p>Card Czar: <span id="currentCzar">Player Name</span></p>
                    </div>

                    <div id="blackCardDisplay" class="black-card">
                        <!-- Current black card will appear here -->
                    </div>

                    <!-- Czar Controls -->
                    <div id="czarControls" class="actions hidden" style="margin-bottom: 20px;">
                        <button class="btn btn-secondary" onclick="previousBlackCard()">‚Üê Previous Card</button>
                        <button class="btn btn-secondary" onclick="nextBlackCard()">Next Card ‚Üí</button>
                        <button class="btn" onclick="confirmBlackCard()">Use This Card</button>
                    </div>

                    <!-- Player Submission Status -->
                    <div id="submissionStatus" class="hidden" style="margin-bottom: 20px;">
                        <h4 style="color: #4ecdc4; text-align: center; margin-bottom: 15px;">Player Submissions</h4>
                        <div id="submissionList" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                            <!-- Submission status will appear here -->
                        </div>
                    </div>

                    <!-- Submitted Cards for Czar to Judge -->
                    <div id="submittedCardsSection" class="hidden" style="margin-bottom: 20px;">
                        <h4 style="color: #ffd700; text-align: center; margin-bottom: 15px;">Choose the Best Answer</h4>
                        <div id="submittedCardsList" class="white-cards">
                            <!-- Submitted cards will appear here -->
                        </div>
                        <div class="actions" style="margin-top: 15px;">
                            <button id="selectWinnerBtn" class="btn" onclick="selectWinner()" disabled>Select Winner</button>
                        </div>
                    </div>

                    <div id="playerHand" class="white-cards">
                        <!-- Player's white cards will appear here -->
                    </div>

                    <!-- Custom Answer Input -->
                    <div id="customAnswerSection" class="hidden" style="margin: 20px 0;">
                        <textarea id="customAnswerInput" placeholder="Write your own answer..." style="width: 100%; height: 80px; padding: 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.1); color: white; resize: vertical;"></textarea>
                        <div style="margin-top: 10px;">
                            <button class="btn btn-small" onclick="submitCustomAnswer()">Submit Custom Answer</button>
                            <button class="btn btn-secondary btn-small" onclick="cancelCustomAnswer()">Cancel</button>
                        </div>
                    </div>

                    <div id="gameActions" class="actions">
                        <button id="submitCard" class="btn" onclick="submitCard()" disabled>Submit Selected Card</button>
                        <button class="btn btn-secondary" onclick="writeCustomAnswer()">Write Custom Answer</button>
                        <button class="btn btn-secondary" onclick="discardHand()">Discard Hand</button>
                        <button class="btn btn-secondary" onclick="leaveGame()">Leave Game</button>
                    </div>
                </div>

                <!-- Game Status -->
                <div id="gameStatus" class="game-status hidden">
                    Waiting for game to start...
                </div>
            </div>
        </div>
    </div>

    <!-- Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <script>
        // Supabase Configuration
        const supabaseUrl = 'https://krrrwuoehltojuzjizqf.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtycnJ3dW9laGx0b2p1emppenFmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkwMTc2MjcsImV4cCI6MjA3NDU5MzYyN30.t36l0IPV3k0WHWSLZbv1fA_nBerBP-t51e9qjzgzXrM';

        // Initialize Supabase
        let supabase;
        try {
            supabase = window.supabase.createClient(supabaseUrl, supabaseKey);
        } catch (error) {
            console.error('Failed to initialize Supabase:', error);
        }

        // Game state
        let currentGame = null;
        let currentPlayer = {
            id: null,
            name: '',
            isHost: false,
            hand: [],
            selectedCard: null,
            selectedSubmission: null
        };
        let blackCardIndex = 0;

        // Default card decks
        const defaultBlackCards = [
            "What's my secret power?",
            "What ended my last relationship?",
            "I drink to forget ___.",
            "What's that sound?",
            "What's the most emo?",
            "What gives me uncontrollable gas?",
            "What's the new fad diet?",
            "What's there a ton of in heaven?",
            "What's Batman's guilty pleasure?",
            "___ + ___ = ___.",
            "In M. Night Shyamalan's new movie, Bruce Willis discovers that ___ had really been ___ all along.",
            "TSA guidelines now prohibit ___ on airplanes.",
            "Coming to Broadway this season, ___: The Musical.",
            "Alternative medicine is now embracing the curative powers of ___.",
            "The Academy Award for ___ goes to ___."
        ];

        const defaultWhiteCards = [
            "A mime having a stroke",
            "The Big Bang",
            "Vigorous jazz hands",
            "The invisible hand",
            "Abstinence",
            "My genitals",
            "Take-backsies",
            "Bling",
            "Poor life choices",
            "Powerful thighs",
            "My sex life",
            "A can of whoop-ass",
            "Dead babies",
            "Switching to Geico",
            "Erectile dysfunction",
            "A sassy black woman",
            "Adderall",
            "Racially-biased SAT questions",
            "The Three-Fifths compromise",
            "My collection of high-tech sex toys",
            "Throwing a virgin into a volcano",
            "The South",
            "Expecting a burp and vomiting on the floor",
            "Cheating in the Special Olympics",
            "Incest",
            "Viagra",
            "Daniel Radcliffe's delicious asshole",
            "A windmill full of corpses",
            "Swooping",
            "Getting so angry you pop a boner"
        ];

        // Utility functions
        function generateId() {
            return Math.random().toString(36).substr(2, 9);
        }

        function generateGameCode() {
            return Math.floor(1000 + Math.random() * 9000).toString();
        }

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function showMessage(message, type = 'success') {
            const messageDiv = document.createElement('div');
            messageDiv.className = type === 'success' ? 'success-message' : 'error-message';
            messageDiv.textContent = message;
            
            document.body.appendChild(messageDiv);
            
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.remove();
                }
            }, 5000);
        }

        // UI Management
        function updateGameStatus(message) {
            const statusEl = document.getElementById('gameStatus');
            if (statusEl) {
                statusEl.textContent = message;
                statusEl.classList.remove('hidden');
            }
        }

        function updatePlayersDisplay(gameData) {
            const playersList = document.getElementById('playersList');
            if (!playersList || !gameData.players) return;

            playersList.innerHTML = '';
            const players = gameData.players;

            Object.values(players).forEach(player => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player-card';
                
                if (player.id === gameData.host_id) {
                    playerDiv.classList.add('host');
                }

                if (gameData.current_czar === player.id) {
                    playerDiv.classList.add('czar');
                }

                playerDiv.innerHTML = `
                    <div class="player-name">
                        ${player.name}
                        ${player.id === gameData.host_id ? ' (Host)' : ''}
                        ${gameData.current_czar === player.id ? ' (Czar)' : ''}
                    </div>
                    <div class="player-score">Score: ${player.score || 0}</div>
                `;
                playersList.appendChild(playerDiv);
            });

            updateScoreboard(gameData);
        }

        function updateScoreboard(gameData) {
            const scoreboardContainer = document.getElementById('scoreboardPlayers');
            const scoreboard = document.getElementById('scoreboard');
            
            if (!scoreboardContainer || !gameData.players) {
                scoreboard && scoreboard.classList.add('hidden');
                return;
            }

            if (gameData.phase === 'waiting') {
                scoreboard.classList.add('hidden');
                return;
            }

            scoreboard.classList.remove('hidden');

            const sortedPlayers = Object.values(gameData.players).sort((a, b) => (b.score || 0) - (a.score || 0));

            scoreboardContainer.innerHTML = '';
            sortedPlayers.forEach((player, index) => {
                const scoreDiv = document.createElement('div');
                scoreDiv.className = 'score-player';
                
                if (player.id === gameData.host_id) {
                    scoreDiv.classList.add('host');
                }

                if (gameData.current_czar === player.id) {
                    scoreDiv.classList.add('czar');
                }

                let rankIndicator = '';
                if (index === 0 && player.score > 0) rankIndicator = 'ü•á';
                else if (index === 1 && player.score > 0) rankIndicator = 'ü•à';
                else if (index === 2 && player.score > 0) rankIndicator = 'ü•â';

                scoreDiv.innerHTML = `
                    <div class="score-player-name">
                        ${rankIndicator} ${player.name}
                        ${player.id === gameData.host_id ? ' (Host)' : ''}
                        ${gameData.current_czar === player.id ? ' (Czar)' : ''}
                    </div>
                    <div class="score-player-points">${player.score || 0}</div>
                `;
                scoreboardContainer.appendChild(scoreDiv);
            });
        }

        // Card Management
        function loadDefaultCards() {
            const blackInput = document.getElementById('blackCardsInput');
            const whiteInput = document.getElementById('whiteCardsInput');
            
            if (blackInput) blackInput.value = defaultBlackCards.join('\n');
            if (whiteInput) whiteInput.value = defaultWhiteCards.join('\n');
            
            showMessage('Default cards loaded!');
        }

        async function updateCards() {
            if (!currentPlayer.isHost || !currentGame) {
                showMessage('Only the host can update cards', 'error');
                return;
            }

            const blackCardsText = document.getElementById('blackCardsInput').value.trim();
            const whiteCardsText = document.getElementById('whiteCardsInput').value.trim();
            const maxRounds = parseInt(document.getElementById('maxRoundsInput').value);
            const cardsPerPlayer = parseInt(document.getElementById('cardsPerPlayerInput').value);

            let blackCards = defaultBlackCards;
            let whiteCards = defaultWhiteCards;

            if (blackCardsText) {
                blackCards = blackCardsText.split('\n').filter(card => card.trim()).map(card => card.trim());
            }

            if (whiteCardsText) {
                whiteCards = whiteCardsText.split('\n').filter(card => card.trim()).map(card => card.trim());
            }

            if (blackCards.length < 5) {
                showMessage('Need at least 5 black cards', 'error');
                return;
            }

            if (whiteCards.length < 20) {
                showMessage('Need at least 20 white cards', 'error');
                return;
            }

            try {
                const { error } = await supabase
                    .from('games')
                    .update({
                        black_cards: blackCards,
                        white_cards: whiteCards,
                        max_rounds: maxRounds,
                        cards_per_player: cardsPerPlayer
                    })
                    .eq('code', currentGame);

                if (error) throw error;

                showMessage('Game settings updated successfully!');
            } catch (error) {
                console.error('Error updating cards:', error);
                showMessage('Error updating cards: ' + error.message, 'error');
            }
        }

        // Game Logic
        async function joinOrCreateGame() {
            const nameInput = document.getElementById('playerName');
            const codeInput = document.getElementById('gameCode');
            const name = nameInput?.value?.trim();
            const code = codeInput?.value?.trim();

            if (!name) {
                showMessage('Please enter your name', 'error');
                return;
            }

            if (code && (!/^\d{4}$/.test(code))) {
                showMessage('Game code must be exactly 4 digits', 'error');
                return;
            }

            currentPlayer.name = name;
            currentPlayer.id = generateId();

            if (code) {
                await joinGame(code);
            } else {
                await createGame();
            }
        }

        async function createGame() {
            const gameCode = generateGameCode();
            currentPlayer.isHost = true;

            const gameData = {
                code: gameCode,
                host_id: currentPlayer.id,
                phase: 'waiting',
                players: {
                    [currentPlayer.id]: {
                        id: currentPlayer.id,
                        name: currentPlayer.name,
                        score: 0,
                        hand: []
                    }
                },
                black_cards: defaultBlackCards,
                white_cards: defaultWhiteCards,
                round: 0,
                max_rounds: 10,
                current_black_card: null,
                current_czar: null,
                submitted_cards: {},
                created_at: new Date().toISOString()
            };

            try {
                const { error } = await supabase
                    .from('games')
                    .insert([gameData]);

                if (error) throw error;

                currentGame = gameCode;
                setupGameListener(gameCode);
                showGameLobby(gameCode);
                showMessage('Game created successfully!');
            } catch (error) {
                console.error('Error creating game:', error);
                showMessage('Error creating game: ' + error.message, 'error');
            }
        }

        async function joinGame(gameCode) {
            try {
                const { data: gameData, error } = await supabase
                    .from('games')
                    .select('*')
                    .eq('code', gameCode)
                    .single();

                if (error || !gameData) {
                    showMessage('Game not found. Please check the code.', 'error');
                    return;
                }

                if (gameData.phase !== 'waiting') {
                    const existingPlayer = Object.values(gameData.players || {}).find(
                        player => player.name === currentPlayer.name
                    );
                    
                    if (existingPlayer) {
                        currentPlayer.id = existingPlayer.id;
                        currentPlayer.hand = existingPlayer.hand || [];
                        currentGame = gameCode;
                        setupGameListener(gameCode);
                        showMessage('Reconnected to game!');
                        return;
                    } else {
                        showMessage('This game has already started and you were not a participant.', 'error');
                        return;
                    }
                }

                const updatedPlayers = {
                    ...gameData.players,
                    [currentPlayer.id]: {
                        id: currentPlayer.id,
                        name: currentPlayer.name,
                        score: 0,
                        hand: []
                    }
                };

                const { error: updateError } = await supabase
                    .from('games')
                    .update({ players: updatedPlayers })
                    .eq('code', gameCode);

                if (updateError) throw updateError;

                currentGame = gameCode;
                setupGameListener(gameCode);
                showGameLobby(gameCode);
                showMessage('Joined game successfully!');
            } catch (error) {
                console.error('Error joining game:', error);
                showMessage('Error joining game: ' + error.message, 'error');
            }
        }

        function setupGameListener(gameCode) {
            console.log('Setting up game listener for code:', gameCode);
            
            const subscription = supabase
                .channel(`game-${gameCode}`)
                .on('postgres_changes',
                    {
                        event: '*',
                        schema: 'public',
                        table: 'games',
                        filter: `code=eq.${gameCode}`
                    },
                    (payload) => {
                        console.log('Real-time update received:', payload);
                        if (payload.new) {
                            updateGameDisplay(payload.new);
                        }
                    }
                )
                .subscribe((status) => {
                    console.log('Subscription status:', status);
                });

            const pollInterval = setInterval(async () => {
                await loadGameData(gameCode);
            }, 3000);

            window.gameCleanup = () => {
                clearInterval(pollInterval);
                supabase.removeChannel(subscription);
            };

            loadGameData(gameCode);
        }

        async function loadGameData(gameCode) {
            try {
                const { data: gameData, error } = await supabase
                    .from('games')
                    .select('*')
                    .eq('code', gameCode)
                    .single();

                if (error || !gameData) {
                    console.error('Error loading game data:', error);
                    return;
                }

                updateGameDisplay(gameData);
            } catch (error) {
                console.error('Error loading game data:', error);
            }
        }

        function updateGameDisplay(gameData) {
            if (!gameData) return;
            
            updatePlayersDisplay(gameData);
            
            // Update kick player list if host controls are visible
            if (currentPlayer.isHost && !document.getElementById('kickPlayerMenu').classList.contains('hidden')) {
                updateKickPlayerList(gameData);
            }

            switch (gameData.phase) {
                case 'waiting':
                    showWaitingPhase(gameData);
                    break;
                case 'playing':
                    showPlayingPhase(gameData);
                    break;
                case 'round_end':
                    showRoundEndPhase(gameData);
                    break;
                case 'game_end':
                    showGameEndPhase(gameData);
                    break;
                default:
                    updateGameStatus('Game in progress...');
                    break;
            }
        }

        function showGameLobby(gameCode) {
            document.getElementById('displayGameCode').textContent = gameCode;
            document.getElementById('mainSection').classList.add('hidden');
            document.getElementById('gameInfoSection').classList.remove('hidden');
            document.getElementById('playersSection').classList.remove('hidden');
            
            if (currentPlayer.isHost) {
                document.getElementById('hostControls').classList.remove('hidden');
                document.getElementById('cardCustomization').classList.remove('hidden');
                // Small delay to ensure DOM is ready
                setTimeout(() => {
                    loadDefaultCards();
                }, 100);
            }
        }

        function showWaitingPhase(gameData) {
            updateGameStatus('Waiting for players to join...');
            document.getElementById('gamePlaySection').classList.add('hidden');
        }

        function showPlayingPhase(gameData) {
            document.getElementById('gameInfoSection').classList.add('hidden');
            document.getElementById('playersSection').classList.add('hidden');
            document.getElementById('cardCustomization').classList.add('hidden');
            document.getElementById('gameStatus').classList.add('hidden');
            document.getElementById('gamePlaySection').classList.remove('hidden');

            document.getElementById('currentRound').textContent = gameData.round || 1;
            document.getElementById('maxRounds').textContent = gameData.max_rounds || 10;
            
            const czarPlayer = Object.values(gameData.players).find(p => p.id === gameData.current_czar);
            document.getElementById('currentCzar').textContent = czarPlayer ? czarPlayer.name : 'Unknown';

            document.getElementById('blackCardDisplay').textContent = gameData.current_black_card || 'Loading...';

            updatePlayerHand(gameData);
        }

        function updatePlayerHand(gameData) {
            const playerHandDiv = document.getElementById('playerHand');
            const submitButton = document.getElementById('submitCard');
            const czarControls = document.getElementById('czarControls');
            const gameActions = document.getElementById('gameActions');
            const submissionStatus = document.getElementById('submissionStatus');
            const submittedCardsSection = document.getElementById('submittedCardsSection');
            
            // Update submission status for all players
            updateSubmissionStatus(gameData);
            
            if (gameData.current_czar === currentPlayer.id) {
                playerHandDiv.innerHTML = '<div style="text-align: center; padding: 20px; color: #ffd700;">You are the Card Czar!</div>';
                submitButton.style.display = 'none';
                gameActions.classList.add('hidden');
                
                // Show black card selection if not confirmed yet
                if (!gameData.black_card_confirmed) {
                    czarControls.classList.remove('hidden');
                    blackCardIndex = gameData.black_card_index || 0;
                    updateBlackCardDisplay(gameData);
                } else {
                    czarControls.classList.add('hidden');
                    // Show submitted cards for judging
                    showSubmittedCardsForJudging(gameData);
                }
                return;
            }

            czarControls.classList.add('hidden');
            submittedCardsSection.classList.add('hidden');
            gameActions.classList.remove('hidden');
            submitButton.style.display = 'inline-block';

            const player = gameData.players[currentPlayer.id];
            const hand = player?.hand || [];

            if (hand.length === 0) {
                playerHandDiv.innerHTML = '<div style="text-align: center; padding: 20px;">Loading your cards...</div>';
                return;
            }

            playerHandDiv.innerHTML = '';
            hand.forEach((card, index) => {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'white-card';
                cardDiv.textContent = card;
                cardDiv.onclick = () => selectCard(index, card);
                
                if (currentPlayer.selectedCard === index) {
                    cardDiv.classList.add('selected');
                }
                
                playerHandDiv.appendChild(cardDiv);
            });

            // Check if player already submitted
            const hasSubmitted = gameData.submitted_cards && gameData.submitted_cards[currentPlayer.id];
            if (hasSubmitted) {
                submitButton.disabled = true;
                submitButton.textContent = 'Card Submitted';
                document.querySelectorAll('.white-card').forEach(card => {
                    card.style.opacity = '0.5';
                    card.onclick = null;
                });
            } else {
                submitButton.disabled = currentPlayer.selectedCard === null;
                submitButton.textContent = 'Submit Selected Card';
            }
        }

        function updateSubmissionStatus(gameData) {
            const submissionStatus = document.getElementById('submissionStatus');
            const submissionList = document.getElementById('submissionList');
            
            if (!gameData.players || gameData.phase !== 'playing') {
                submissionStatus.classList.add('hidden');
                return;
            }

            submissionStatus.classList.remove('hidden');
            submissionList.innerHTML = '';

            Object.values(gameData.players).forEach(player => {
                if (player.id === gameData.current_czar) return; // Skip czar
                
                const statusDiv = document.createElement('div');
                statusDiv.style.cssText = 'padding: 10px; border-radius: 8px; text-align: center; border: 1px solid rgba(255,255,255,0.2);';
                
                const hasSubmitted = gameData.submitted_cards && gameData.submitted_cards[player.id];
                
                if (hasSubmitted) {
                    statusDiv.style.background = 'rgba(40, 167, 69, 0.2)';
                    statusDiv.style.borderColor = '#28a745';
                    statusDiv.innerHTML = `<div style="color: #28a745; font-weight: bold;">${player.name}</div><div style="color: #28a745; font-size: 12px;">‚úì Submitted</div>`;
                } else {
                    statusDiv.style.background = 'rgba(255, 193, 7, 0.2)';
                    statusDiv.style.borderColor = '#ffc107';
                    statusDiv.innerHTML = `<div style="color: #ffc107; font-weight: bold;">${player.name}</div><div style="color: #ffc107; font-size: 12px;">‚è≥ Waiting</div>`;
                }
                
                submissionList.appendChild(statusDiv);
            });
        }

        function showSubmittedCardsForJudging(gameData) {
            const submittedCardsSection = document.getElementById('submittedCardsSection');
            const submittedCardsList = document.getElementById('submittedCardsList');
            
            if (!gameData.submitted_cards || Object.keys(gameData.submitted_cards).length === 0) {
                submittedCardsSection.classList.add('hidden');
                return;
            }

            submittedCardsSection.classList.remove('hidden');
            submittedCardsList.innerHTML = '';

            // Shuffle the submissions to anonymize them
            const submissions = Object.entries(gameData.submitted_cards);
            const shuffledSubmissions = submissions.sort(() => Math.random() - 0.5);

            shuffledSubmissions.forEach(([playerId, cardText], index) => {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'white-card';
                cardDiv.textContent = cardText;
                cardDiv.onclick = () => selectSubmission(playerId, cardText, cardDiv);
                cardDiv.dataset.playerId = playerId;
                
                submittedCardsList.appendChild(cardDiv);
            });
        }

        function selectSubmission(playerId, cardText, cardElement) {
            // Remove previous selection
            document.querySelectorAll('#submittedCardsList .white-card').forEach(c => c.classList.remove('selected'));
            
            // Add selection to clicked card
            cardElement.classList.add('selected');
            currentPlayer.selectedSubmission = playerId;
            
            // Enable select winner button
            document.getElementById('selectWinnerBtn').disabled = false;
        }

        async function selectWinner() {
            if (!currentPlayer.selectedSubmission) return;

            try {
                const { data: gameData, error: fetchError } = await supabase
                    .from('games')
                    .select('*')
                    .eq('code', currentGame)
                    .single();

                if (fetchError) throw fetchError;

                const winnerPlayer = gameData.players[currentPlayer.selectedSubmission];
                
                // Update winner's score
                const updatedPlayers = {
                    ...gameData.players,
                    [currentPlayer.selectedSubmission]: {
                        ...winnerPlayer,
                        score: (winnerPlayer.score || 0) + 1
                    }
                };

                // Move to next round or end game
                const nextRound = (gameData.round || 1) + 1;
                const maxRounds = gameData.max_rounds || 10;
                
                let updateData = {
                    players: updatedPlayers,
                    submitted_cards: {},
                    black_card_confirmed: false
                };

                if (nextRound > maxRounds) {
                    updateData.phase = 'game_end';
                } else {
                    // Next player becomes czar
                    const playerIds = Object.keys(gameData.players);
                    const currentCzarIndex = playerIds.indexOf(gameData.current_czar);
                    const nextCzarIndex = (currentCzarIndex + 1) % playerIds.length;
                    
                    updateData.round = nextRound;
                    updateData.current_czar = playerIds[nextCzarIndex];
                    updateData.black_card_index = 0;
                    updateData.current_black_card = gameData.black_cards[0];
                }

                const { error: updateError } = await supabase
                    .from('games')
                    .update(updateData)
                    .eq('code', currentGame);

                if (updateError) throw updateError;

                currentPlayer.selectedSubmission = null;
                showMessage(`${winnerPlayer.name} wins this round!`);

            } catch (error) {
                console.error('Error selecting winner:', error);
                showMessage('Error selecting winner: ' + error.message, 'error');
            }
        }

        // Player management functions
        function showKickMenu() {
            const kickMenu = document.getElementById('kickPlayerMenu');
            const playerSelect = document.getElementById('playerToKick');
            
            kickMenu.classList.remove('hidden');
            
            // Populate player list
            loadGameData(currentGame).then(() => {
                // This will be populated after game data loads
            });
        }

        function hideKickMenu() {
            document.getElementById('kickPlayerMenu').classList.add('hidden');
        }

        function updateKickPlayerList(gameData) {
            if (!currentPlayer.isHost) return;
            
            const playerSelect = document.getElementById('playerToKick');
            playerSelect.innerHTML = '<option value="">Select player to remove...</option>';
            
            Object.values(gameData.players).forEach(player => {
                if (player.id !== currentPlayer.id) { // Don't allow kicking yourself
                    const option = document.createElement('option');
                    option.value = player.id;
                    option.textContent = player.name;
                    playerSelect.appendChild(option);
                }
            });
        }

        async function kickPlayer() {
            const playerToKickId = document.getElementById('playerToKick').value;
            if (!playerToKickId) {
                showMessage('Please select a player to remove', 'error');
                return;
            }

            try {
                const { data: gameData, error: fetchError } = await supabase
                    .from('games')
                    .select('*')
                    .eq('code', currentGame)
                    .single();

                if (fetchError) throw fetchError;

                const playerToKick = gameData.players[playerToKickId];
                const updatedPlayers = { ...gameData.players };
                delete updatedPlayers[playerToKickId];

                // If kicked player was czar, pick new czar
                let updateData = { players: updatedPlayers };
                if (gameData.current_czar === playerToKickId) {
                    const remainingPlayerIds = Object.keys(updatedPlayers);
                    if (remainingPlayerIds.length > 0) {
                        updateData.current_czar = remainingPlayerIds[0];
                    }
                }

                const { error: updateError } = await supabase
                    .from('games')
                    .update(updateData)
                    .eq('code', currentGame);

                if (updateError) throw updateError;

                hideKickMenu();
                showMessage(`${playerToKick.name} has been removed from the game`);

            } catch (error) {
                console.error('Error kicking player:', error);
                showMessage('Error removing player: ' + error.message, 'error');
            }
        }

        function updateBlackCardDisplay(gameData) {
            const blackCards = gameData.black_cards || [];
            const displayCard = blackCards[blackCardIndex] || 'No card available';
            document.getElementById('blackCardDisplay').textContent = displayCard;
        }

        // Card Czar functions
        async function previousBlackCard() {
            const { data: gameData, error } = await supabase
                .from('games')
                .select('*')
                .eq('code', currentGame)
                .single();

            if (error || !gameData) return;

            const blackCards = gameData.black_cards || [];
            blackCardIndex = (blackCardIndex - 1 + blackCards.length) % blackCards.length;
            
            await supabase
                .from('games')
                .update({ black_card_index: blackCardIndex })
                .eq('code', currentGame);

            updateBlackCardDisplay(gameData);
        }

        async function nextBlackCard() {
            const { data: gameData, error } = await supabase
                .from('games')
                .select('*')
                .eq('code', currentGame)
                .single();

            if (error || !gameData) return;

            const blackCards = gameData.black_cards || [];
            blackCardIndex = (blackCardIndex + 1) % blackCards.length;
            
            await supabase
                .from('games')
                .update({ black_card_index: blackCardIndex })
                .eq('code', currentGame);

            updateBlackCardDisplay(gameData);
        }

        async function confirmBlackCard() {
            const { data: gameData, error } = await supabase
                .from('games')
                .select('*')
                .eq('code', currentGame)
                .single();

            if (error || !gameData) return;

            const selectedCard = gameData.black_cards[blackCardIndex];
            
            await supabase
                .from('games')
                .update({ 
                    current_black_card: selectedCard,
                    black_card_confirmed: true
                })
                .eq('code', currentGame);

            showMessage('Black card confirmed! Players can now submit answers.');
        }

        // Custom answer functions
        function writeCustomAnswer() {
            document.getElementById('customAnswerSection').classList.remove('hidden');
            document.getElementById('gameActions').style.display = 'none';
            currentPlayer.selectedCard = null;
            document.querySelectorAll('.white-card').forEach(c => c.classList.remove('selected'));
        }

        function cancelCustomAnswer() {
            document.getElementById('customAnswerSection').classList.add('hidden');
            document.getElementById('gameActions').style.display = 'flex';
            document.getElementById('customAnswerInput').value = '';
        }

        async function submitCustomAnswer() {
            const customText = document.getElementById('customAnswerInput').value.trim();
            if (!customText) {
                showMessage('Please enter an answer', 'error');
                return;
            }

            try {
                const { data: gameData, error: fetchError } = await supabase
                    .from('games')
                    .select('*')
                    .eq('code', currentGame)
                    .single();

                if (fetchError) throw fetchError;

                const updatedSubmissions = {
                    ...gameData.submitted_cards,
                    [currentPlayer.id]: customText
                };

                const { error: updateError } = await supabase
                    .from('games')
                    .update({ submitted_cards: updatedSubmissions })
                    .eq('code', currentGame);

                if (updateError) throw updateError;

                cancelCustomAnswer();
                showMessage('Custom answer submitted!');

            } catch (error) {
                console.error('Error submitting custom answer:', error);
                showMessage('Error submitting answer: ' + error.message, 'error');
            }
        }

        // Discard hand function
        async function discardHand() {
            if (!confirm('Are you sure you want to discard your hand and draw new cards?')) return;

            try {
                const { data: gameData, error: fetchError } = await supabase
                    .from('games')
                    .select('*')
                    .eq('code', currentGame)
                    .single();

                if (fetchError) throw fetchError;

                const player = gameData.players[currentPlayer.id];
                const cardsPerPlayer = gameData.cards_per_player || 7;
                const whiteCards = [...gameData.white_cards];
                
                // Get new hand
                const newHand = [];
                for (let i = 0; i < cardsPerPlayer; i++) {
                    if (whiteCards.length > 0) {
                        const randomIndex = Math.floor(Math.random() * whiteCards.length);
                        newHand.push(whiteCards[randomIndex]);
                        whiteCards.splice(randomIndex, 1);
                    }
                }

                const updatedPlayers = {
                    ...gameData.players,
                    [currentPlayer.id]: {
                        ...player,
                        hand: newHand
                    }
                };

                const { error: updateError } = await supabase
                    .from('games')
                    .update({ players: updatedPlayers })
                    .eq('code', currentGame);

                if (updateError) throw updateError;

                currentPlayer.selectedCard = null;
                showMessage('Hand discarded! New cards dealt.');

            } catch (error) {
                console.error('Error discarding hand:', error);
                showMessage('Error discarding hand: ' + error.message, 'error');
            }
        }

        function selectCard(index, card) {
            document.querySelectorAll('.white-card').forEach(c => c.classList.remove('selected'));
            
            event.target.classList.add('selected');
            currentPlayer.selectedCard = index;
            
            document.getElementById('submitCard').disabled = false;
        }

        async function submitCard() {
            if (currentPlayer.selectedCard === null) return;

            try {
                const { data: gameData, error: fetchError } = await supabase
                    .from('games')
                    .select('*')
                    .eq('code', currentGame)
                    .single();

                if (fetchError) throw fetchError;

                const player = gameData.players[currentPlayer.id];
                const selectedCardText = player.hand[currentPlayer.selectedCard];

                const updatedSubmissions = {
                    ...gameData.submitted_cards,
                    [currentPlayer.id]: selectedCardText
                };

                const updatedHand = [...player.hand];
                updatedHand.splice(currentPlayer.selectedCard, 1);

                const updatedPlayers = {
                    ...gameData.players,
                    [currentPlayer.id]: {
                        ...player,
                        hand: updatedHand
                    }
                };

                const { error: updateError } = await supabase
                    .from('games')
                    .update({
                        submitted_cards: updatedSubmissions,
                        players: updatedPlayers
                    })
                    .eq('code', currentGame);

                if (updateError) throw updateError;

                currentPlayer.selectedCard = null;
                showMessage('Card submitted!');

            } catch (error) {
                console.error('Error submitting card:', error);
                showMessage('Error submitting card: ' + error.message, 'error');
            }
        }

        function showRoundEndPhase(gameData) {
            updateGameStatus('Round ended! Preparing next round...');
        }

        function showGameEndPhase(gameData) {
            updateGameStatus('Game finished! Thanks for playing!');
        }

        async function refreshGameData() {
            if (!currentGame) return;
            console.log('Manually refreshing game data for:', currentGame);
            await loadGameData(currentGame);
            showMessage('Game data refreshed!');
        }

        async function startGame() {
            if (!currentPlayer.isHost) return;

            try {
                const { data: gameData, error: fetchError } = await supabase
                    .from('games')
                    .select('*')
                    .eq('code', currentGame)
                    .single();

                if (fetchError) throw fetchError;

                const playerCount = Object.keys(gameData.players).length;

                if (playerCount < 3) {
                    showMessage('Need at least 3 players to start', 'error');
                    return;
                }

                const firstCzar = gameData.host_id;
                const cardsPerPlayer = gameData.cards_per_player || 7;

                const updatedPlayers = { ...gameData.players };
                const whiteCards = [...gameData.white_cards];
                let cardIndex = 0;

                Object.keys(updatedPlayers).forEach(playerId => {
                    const hand = [];
                    for (let i = 0; i < cardsPerPlayer; i++) {
                        if (cardIndex < whiteCards.length) {
                            hand.push(whiteCards[cardIndex]);
                            cardIndex++;
                        }
                    }
                    updatedPlayers[playerId].hand = hand;
                });

                const firstBlackCard = gameData.black_cards[0];

                const { error: updateError } = await supabase
                    .from('games')
                    .update({
                        phase: 'playing',
                        round: 1,
                        current_czar: firstCzar,
                        current_black_card: firstBlackCard,
                        players: updatedPlayers,
                        submitted_cards: {},
                        black_card_index: 0,
                        black_card_confirmed: false
                    })
                    .eq('code', currentGame);

                if (updateError) throw updateError;

                showMessage('Game started!');
            } catch (error) {
                console.error('Error starting game:', error);
                showMessage('Error starting game: ' + error.message, 'error');
            }
        }

        async function leaveGame() {
            if (confirm('Are you sure you want to leave the game?')) {
                if (window.gameCleanup) {
                    window.gameCleanup();
                }
                location.reload();
            }
        }

        async function initializeApp() {
            try {
                const { data, error } = await supabase.from('games').select('count').limit(1);
                
                if (error) {
                    console.error('Supabase connection error:', error);
                    showMessage('Database connection failed. Please refresh the page.', 'error');
                } else {
                    console.log('Supabase connected successfully');
                    updateGameStatus('Welcome! Enter your name to join or create a game.');
                }
            } catch (error) {
                console.error('Initialization error:', error);
                showMessage('Failed to initialize game. Please refresh the page.', 'error');
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('playerName')?.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    joinOrCreateGame();
                }
            });

            document.getElementById('gameCode')?.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    joinOrCreateGame();
                }
            });

            window.joinOrCreateGame = joinOrCreateGame;
            window.startGame = startGame;
            window.refreshGameData = refreshGameData;
            window.loadDefaultCards = loadDefaultCards;
            window.updateCards = updateCards;
            window.submitCard = submitCard;
            window.leaveGame = leaveGame;
            window.previousBlackCard = previousBlackCard;
            window.nextBlackCard = nextBlackCard;
            window.confirmBlackCard = confirmBlackCard;
            window.writeCustomAnswer = writeCustomAnswer;
            window.cancelCustomAnswer = cancelCustomAnswer;
            window.submitCustomAnswer = submitCustomAnswer;
            window.discardHand = discardHand;
            window.selectWinner = selectWinner;
            window.showKickMenu = showKickMenu;
            window.hideKickMenu = hideKickMenu;
            window.kickPlayer = kickPlayer;
            
            initializeApp();
        });
    </script>
</body>
</html>
