<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Private Game Room</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
            display: flex;
        }

        .game-layout {
            display: flex;
            width: 100%;
            gap: 20px;
        }

        .scoreboard {
            width: 250px;
            flex-shrink: 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            height: fit-content;
            position: sticky;
            top: 20px;
        }

        .scoreboard h3 {
            text-align: center;
            color: #ff6b6b;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
        }

        .score-player {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-left: 3px solid transparent;
        }

        .score-player.host {
            border-left-color: #ff6b6b;
        }

        .score-player.czar {
            border-left-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
        }

        .score-player-name {
            font-weight: bold;
            font-size: 14px;
        }

        .score-player-points {
            color: #4ecdc4;
            font-weight: bold;
            font-size: 16px;
        }

        .main-content {
            flex: 1;
            min-width: 0;
        }

        .container {
            max-width: none;
            margin: 0;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: #ff6b6b;
        }

        .game-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .join-form {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .join-form input, .join-form button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
        }

        .join-form input {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            flex: 1;
            min-width: 200px;
        }

        .join-form input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .btn {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 16px;
        }

        .btn:hover {
            background: linear-gradient(135deg, #ee5a52, #ff6b6b);
            transform: translateY(-2px);
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #44a08d, #4ecdc4);
        }

        .game-info {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .game-code {
            font-size: 3rem;
            font-weight: bold;
            color: #4ecdc4;
            margin: 10px 0;
            letter-spacing: 8px;
            font-family: 'Courier New', monospace;
        }

        .players-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .player-card {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            padding: 15px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            position: relative;
        }

        .player-card.czar {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.2);
        }

        .player-card.host {
            border-color: #ff6b6b;
        }

        .player-name {
            font-weight: bold;
            font-size: 18px;
            margin-bottom: 5px;
        }

        .player-score {
            color: #4ecdc4;
            font-size: 24px;
            font-weight: bold;
        }

        .hidden {
            display: none;
        }

        .game-status {
            text-align: center;
            font-size: 18px;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .success-message {
            background: rgba(40, 167, 69, 0.2);
            border: 1px solid #28a745;
            color: #28a745;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
        }

        .error-message {
            background: rgba(220, 53, 69, 0.2);
            border: 1px solid #dc3545;
            color: #dc3545;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
        }

        .deck-stats {
            margin: 15px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            text-align: center;
        }

        .deck-stats h4 {
            color: #4ecdc4;
            margin-bottom: 5px;
        }

        .deck-management-actions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .textarea-container {
            position: relative;
            margin-bottom: 20px;
        }

        .textarea-container textarea {
            width: 100%;
            height: 150px;
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
            resize: vertical;
            font-family: Arial, sans-serif;
        }

        .textarea-container textarea::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .card-counter {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        .removable-card {
            margin: 5px 0;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s ease;
            border-left: 3px solid transparent;
        }

        .removable-card:hover {
            background: rgba(255, 99, 107, 0.3);
            border-left-color: #dc3545;
        }

        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }
            
            .game-layout {
                flex-direction: column;
            }
            
            .scoreboard {
                width: 100%;
                position: static;
                order: -1;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .join-form {
                flex-direction: column;
            }
            
            .join-form input {
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <div class="game-layout">
        <!-- Scoreboard -->
        <div id="scoreboard" class="scoreboard hidden">
            <h3>üèÜ Scoreboard</h3>
            <div id="scoreboardPlayers">
                <!-- Score list will be populated here -->
            </div>
        </div>

        <!-- Main Game Content -->
        <div class="main-content">
            <div class="container">
                <div class="header">
                    <h1>üé≤ Private Game Room</h1>
                    <p>A card game for friends who aren't easily offended</p>
                </div>

                <!-- Start/Join Game Section -->
                <div id="mainSection" class="game-section">
                    <h2 style="text-align: center; margin-bottom: 20px;">Join or Create Game</h2>
                    <div class="join-form">
                        <input type="text" id="playerName" placeholder="Enter your name" maxlength="20">
                        <input type="text" id="gameCode" placeholder="Game code (leave empty to create)" maxlength="4">
                        <button class="btn" onclick="joinOrCreateGame()">Join/Create Game</button>
                    </div>
                    
                    <div class="actions" style="margin-top: 20px;">
                        <button class="btn btn-secondary" onclick="showGlobalCardManagement()">Manage Global Card Decks</button>
                    </div>
                </div>

                <!-- Global Card Management Modal -->
                <div id="globalCardManagementModal" class="game-section hidden" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000; max-height: 90vh; overflow-y: auto; width: 95%; max-width: 900px;">
                    <h2 style="text-align: center; margin-bottom: 20px;">üé¥ Manage Global Card Decks</h2>
                    <p style="text-align: center; margin-bottom: 20px; color: #4ecdc4;">Changes made here will affect ALL future games</p>
                    
                    <div class="deck-management-actions">
                        <button class="btn btn-secondary" onclick="switchCardType('black')">Edit Black Cards</button>
                        <button class="btn btn-secondary" onclick="switchCardType('white')">Edit White Cards</button>
                        <button class="btn" style="background: linear-gradient(135deg, #ffc107, #e0a800);" onclick="resetToDefaults()">Reset to Defaults</button>
                        <button class="btn" onclick="closeGlobalCardManagement()">Done</button>
                    </div>

                    <div id="deckStats" class="deck-stats">
                        <!-- Deck statistics will be shown here -->
                    </div>

                    <div id="messageContainer">
                        <!-- Success/error messages will appear here -->
                    </div>
                    
                    <div class="textarea-container">
                        <h4 id="globalCardTypeTitle">Add New Black Cards:</h4>
                        <textarea id="globalBulkCardInput" placeholder="Paste cards here, one per line...&#10;&#10;Example:&#10;What's the next Happy Meal toy?&#10;___: kid tested, mother approved.&#10;I drink to forget ___."></textarea>
                        <div class="card-counter" id="cardCounter">0 cards</div>
                    </div>
                    
                    <div class="actions" style="margin-bottom: 20px;">
                        <button class="btn btn-secondary" onclick="addGlobalBulkCards()">Add Cards to Global Deck</button>
                        <button class="btn" style="background: linear-gradient(135deg, #dc3545, #c82333);" onclick="clearAllCards()">Clear All Cards of This Type</button>
                    </div>
                    
                    <h4 style="margin: 20px 0;">Current Cards (click to remove):</h4>
                    <div id="globalCurrentCardsList" style="max-height: 400px; overflow-y: auto; background: rgba(0,0,0,0.1); padding: 15px; border-radius: 10px;">
                        <!-- Current cards will be listed here -->
                    </div>
                </div>

                <!-- Game Info Section -->
                <div id="gameInfoSection" class="game-section hidden">
                    <div class="game-info">
                        <h3>Game Code:</h3>
                        <div class="game-code" id="displayGameCode"></div>
                        <p>Share this code with friends to let them join!</p>
                    </div>
                </div>

                <!-- Players List -->
                <div id="playersSection" class="game-section hidden">
                    <h2 style="text-align: center; margin-bottom: 20px;">Players</h2>
                    <div id="playersList" class="players-list">
                        <!-- Players will be populated here -->
                    </div>
                    <div id="hostControls" class="hidden">
                        <div class="actions" style="margin-top: 15px;">
                            <button class="btn btn-secondary" onclick="refreshGameData()">Refresh Player List</button>
                            <button class="btn" onclick="startGame()">Start Game</button>
                        </div>
                    </div>
                </div>

                <!-- Game Status -->
                <div id="gameStatus" class="game-status hidden">
                    Waiting for game to start...
                </div>
            </div>
        </div>
    </div>

    <!-- Supabase SDK -->
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>

    <script>
        // Supabase Configuration
        const supabaseUrl = 'https://krrrwuoehltojuzjizqf.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtycnJ3dW9laGx0b2p1emppenFmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkwMTc2MjcsImV4cCI6MjA3NDU5MzYyN30.t36l0IPV3k0WHWSLZbv1fA_nBerBP-t51e9qjzgzXrM';

        // Initialize Supabase
        const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

        // Game state
        let currentGame = null;
        let currentPlayer = {
            id: null,
            name: '',
            isHost: false
        };
        let globalCardType = 'black';

        // Default card decks
        const defaultBlackCards = [
            "___: kid tested, mother approved.",
            "___? There's an app for that.",
            "What's the next Happy Meal toy?",
            "In his new self-produced album, Kanye West raps over the sounds of ___.",
            "What ended my last relationship?",
            "I drink to forget ___.",
            "What's that sound?",
            "What's the most emo?",
            "Instead of coal, Santa now gives the bad children ___.",
            "What gives me uncontrollable gas?",
            "The Academy Award for ___ goes to ___.",
            "What's my secret power?",
            "___ + ___ = ___.",
            "In M. Night Shyamalan's new movie, Bruce Willis discovers that ___ had really been ___ all along.",
            "What's the new fad diet?",
            "What's there a ton of in heaven?",
            "Coming to Broadway this season, ___: The Musical.",
            "Alternative medicine is now embracing the curative powers of ___.",
            "What's Batman's guilty pleasure?",
            "TSA guidelines now prohibit ___ on airplanes."
        ];

        const defaultWhiteCards = [
            "A mime having a stroke",
            "The Big Bang",
            "Getting so angry you pop a boner",
            "Vigorous jazz hands",
            "A windmill full of corpses",
            "Swooping",
            "The invisible hand",
            "A sassy black woman",
            "Abstinence",
            "Adderall",
            "My genitals",
            "Racially-biased SAT questions",
            "The Three-Fifths compromise",
            "Take-backsies",
            "My collection of high-tech sex toys",
            "Throwing a virgin into a volcano",
            "Bling",
            "Poor life choices",
            "Powerful thighs",
            "The South",
            "Expecting a burp and vomiting on the floor",
            "Cheating in the Special Olympics",
            "My sex life",
            "Incest",
            "A can of whoop-ass",
            "Viagra",
            "Dead babies",
            "Switching to Geico",
            "Daniel Radcliffe's delicious asshole",
            "Erectile dysfunction"
        ];

        // Utility functions
        function generateId() {
            return Math.random().toString(36).substr(2, 9);
        }

        function generateGameCode() {
            return Math.floor(1000 + Math.random() * 9000).toString();
        }

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function getRandomCards(deck, count) {
            return shuffleArray(deck).slice(0, count);
        }

        function showMessage(message, type = 'success') {
            const messageDiv = document.createElement('div');
            messageDiv.className = type === 'success' ? 'success-message' : 'error-message';
            messageDiv.textContent = message;
            
            document.body.appendChild(messageDiv);
            
            setTimeout(() => {
                messageDiv.remove();
            }, 5000);
        }

        function updateCardCounter() {
            const textarea = document.getElementById('globalBulkCardInput');
            const counter = document.getElementById('cardCounter');
            if (textarea && counter) {
                const lines = textarea.value.split('\n').filter(line => line.trim()).length;
                counter.textContent = `${lines} card${lines !== 1 ? 's' : ''}`;
            }
        }

        // Global Card Management Functions
        async function showGlobalCardManagement() {
            const overlay = document.createElement('div');
            overlay.className = 'overlay';
            overlay.onclick = closeGlobalCardManagement;
            document.body.appendChild(overlay);
            
            document.getElementById('globalCardManagementModal').classList.remove('hidden');
            await switchCardType('black');
            updateDeckStats();
        }

        function closeGlobalCardManagement() {
            document.getElementById('globalCardManagementModal').classList.add('hidden');
            const overlay = document.querySelector('.overlay');
            if (overlay) overlay.remove();
            document.getElementById('globalBulkCardInput').value = '';
            document.getElementById('messageContainer').innerHTML = '';
        }

        async function switchCardType(type) {
            globalCardType = type;
            document.getElementById('globalCardTypeTitle').textContent = 
                `Add New ${type.charAt(0).toUpperCase() + type.slice(1)} Cards:`;
            
            const textarea = document.getElementById('globalBulkCardInput');
            if (type === 'black') {
                textarea.placeholder = `Paste black cards here, one per line...

Example:
What's the next Happy Meal toy?
___: kid tested, mother approved.
I drink to forget ___.
___ + ___ = ___.`;
            } else {
                textarea.placeholder = `Paste white cards here, one per line...

Example:
A mime having a stroke
Vigorous jazz hands
My collection of high-tech sex toys
Poor life choices`;
            }
            
            await updateGlobalCurrentCardsList();
            updateDeckStats();
        }

        async function updateDeckStats() {
            try {
                const cardDecks = await getCardDecks();
                const blackCount = cardDecks.blackCards ? cardDecks.blackCards.length : 0;
                const whiteCount = cardDecks.whiteCards ? cardDecks.whiteCards.length : 0;
                
                document.getElementById('deckStats').innerHTML = `
                    <h4>Current Deck Status</h4>
                    <p>Black Cards: ${blackCount} | White Cards: ${whiteCount}</p>
                    <p>Total Cards: ${blackCount + whiteCount}</p>
                    <small>Last updated: ${cardDecks.lastUpdated ? new Date(cardDecks.lastUpdated).toLocaleDateString() : 'Never'}</small>
                `;
            } catch (error) {
                console.error('Error updating deck stats:', error);
            }
        }

        async function getCardDecks() {
            try {
                const { data, error } = await supabase
                    .from('card_decks')
                    .select('*')
                    .order('id', { ascending: false })
                    .limit(1);

                if (error) {
                    console.error('Error fetching card decks:', error);
                    return getDefaultDecks();
                }

                if (!data || data.length === 0) {
                    console.log('No card decks found, using defaults');
                    return getDefaultDecks();
                }

                const latest = data[0];
                return {
                    blackCards: latest.blackCards || defaultBlackCards,
                    whiteCards: latest.whiteCards || defaultWhiteCards,
                    lastUpdated: latest.lastUpdated || Date.now(),
                    version: latest.version || 1
                };
            } catch (error) {
                console.error('Error in getCardDecks:', error);
                return getDefaultDecks();
            }
        }

        function getDefaultDecks() {
            return {
                blackCards: [...defaultBlackCards],
                whiteCards: [...defaultWhiteCards],
                lastUpdated: Date.now(),
                version: 1
            };
        }

        async function updateGlobalCurrentCardsList() {
            try {
                const cardDecks = await getCardDecks();
                const cards = globalCardType === 'black' ? cardDecks.blackCards : cardDecks.whiteCards;
                const listContainer = document.getElementById('globalCurrentCardsList');
                
                if (!cards || cards.length === 0) {
                    listContainer.innerHTML = `<p style="text-align: center; color: #999; padding: 20px;">No ${globalCardType} cards found. Add some cards above!</p>`;
                    return;
                }
                
                listContainer.innerHTML = cards.map((card, index) => 
                    `<div class="removable-card" onclick="removeGlobalCard(${index})" title="Click to remove this card permanently">
                        <strong>${index + 1}.</strong> ${card}
                    </div>`
                ).join('');
            } catch (error) {
                console.error('Error updating cards list:', error);
            }
        }

        async function addGlobalBulkCards() {
            const textarea = document.getElementById('globalBulkCardInput');
            if (!textarea || !textarea.value) {
                showMessage('Please enter some cards, one per line', 'error');
                return;
            }
            
            const newCards = textarea.value.split('\n')
                .map(card => card.trim())
                .filter(card => card && card.length > 0);
            
            if (newCards.length === 0) {
                showMessage('Please enter some cards, one per line', 'error');
                return;
            }

            try {
                const cardDecks = await getCardDecks();
                const existingCards = globalCardType === 'black' ? (cardDecks.blackCards || []) : (cardDecks.whiteCards || []);
                
                const duplicates = newCards.filter(card => existingCards.includes(card));
                const uniqueNewCards = newCards.filter(card => !existingCards.includes(card));
                
                if (uniqueNewCards.length === 0) {
                    showMessage('All cards already exist in the deck', 'error');
                    return;
                }

                const combinedCards = [...existingCards, ...uniqueNewCards];

                await updateGlobalCardDecks(
                    globalCardType === 'black' ? combinedCards : (cardDecks.blackCards || []),
                    globalCardType === 'white' ? combinedCards : (cardDecks.whiteCards || [])
                );
                
                let message = `Successfully added ${uniqueNewCards.length} ${globalCardType} cards to global deck!`;
                if (duplicates.length > 0) {
                    message += ` (${duplicates.length} duplicates skipped)`;
                }
                
                showMessage(message);
                textarea.value = '';
                updateCardCounter();
                await updateGlobalCurrentCardsList();
                updateDeckStats();
            } catch (error) {
                console.error('Error adding cards:', error);
                showMessage('Error adding cards: ' + error.message, 'error');
            }
        }

        async function updateGlobalCardDecks(blackCards, whiteCards) {
            try {
                const deckData = {
                    blackCards: blackCards,
                    whiteCards: whiteCards,
                    lastUpdated: Date.now(),
                    version: 1
                };

                // First try to update existing record
                const { data: existingData, error: fetchError } = await supabase
                    .from('card_decks')
                    .select('id')
                    .order('id', { ascending: false })
                    .limit(1);

                if (fetchError) {
                    console.error('Error fetching existing decks:', fetchError);
                }

                if (existingData && existingData.length > 0) {
                    // Update existing record
                    const { error: updateError } = await supabase
                        .from('card_decks')
                        .update(deckData)
                        .eq('id', existingData[0].id);
                    
                    if (updateError) throw updateError;
                } else {
                    // Insert new record
                    const { error: insertError } = await supabase
                        .from('card_decks')
                        .insert([deckData]);
                    
                    if (insertError) throw insertError;
                }

                console.log('Card decks updated successfully');
            } catch (error) {
                console.error('Error updating global card decks:', error);
                throw error;
            }
        }

        async function removeGlobalCard(index) {
            if (!confirm(`Remove this ${globalCardType} card permanently from all games?`)) return;

            try {
                const cardDecks = await getCardDecks();
                const cardArray = globalCardType === 'black' ? cardDecks.blackCards : cardDecks.whiteCards;
                
                if (!cardArray || index >= cardArray.length) {
                    showMessage('Card not found', 'error');
                    return;
                }
                
                const removedCard = cardArray[index];
                cardArray.splice(index, 1);
                
                await updateGlobalCardDecks(
                    globalCardType === 'black' ? cardArray : cardDecks.blackCards,
                    globalCardType === 'white' ? cardArray : cardDecks.whiteCards
                );
                
                showMessage(`"${removedCard}" removed from ${globalCardType} deck!`);
                await updateGlobalCurrentCardsList();
                updateDeckStats();
            } catch (error) {
                console.error('Error removing card:', error);
                showMessage('Error removing card: ' + error.message, 'error');
            }
        }

        async function clearAllCards() {
            const cardType = globalCardType;
            if (!confirm(`Are you sure you want to clear ALL ${cardType} cards? This will affect all games and cannot be undone!`)) {
                return;
            }

            if (!confirm(`This will permanently delete all ${cardType} cards from the global deck. Are you absolutely sure?`)) {
                return;
            }

            try {
                const cardDecks = await getCardDecks();
                
                await updateGlobalCardDecks(
                    cardType === 'black' ? [] : cardDecks.blackCards,
                    cardType === 'white' ? [] : cardDecks.whiteCards
                );
                
                showMessage(`All ${cardType} cards have been cleared from the global deck`);
                await updateGlobalCurrentCardsList();
                updateDeckStats();
            } catch (error) {
                console.error('Error clearing cards:', error);
                showMessage('Error clearing cards: ' + error.message, 'error');
            }
        }

        async function resetToDefaults() {
            if (!confirm('Reset card decks to default? This will replace all current cards with the original set.')) {
                return;
            }

            try {
                await updateGlobalCardDecks(defaultBlackCards, defaultWhiteCards);
                showMessage('Card decks reset to defaults!');
                await updateGlobalCurrentCardsList();
                updateDeckStats();
            } catch (error) {
                console.error('Error resetting cards:', error);
                showMessage('Error resetting cards: ' + error.message, 'error');
            }
        }
        function showSection(sectionId) {
            document.querySelectorAll('.game-section, #gameStatus').forEach(section => {
                section.classList.add('hidden');
            });
            const section = document.getElementById(sectionId);
            if (section) section.classList.remove('hidden');
        }

        function updateGameStatus(message) {
            const statusEl = document.getElementById('gameStatus');
            statusEl.textContent = message;
            statusEl.classList.remove('hidden');
        }

        function updatePlayersDisplay(gameData) {
            const playersList = document.getElementById('playersList');
            playersList.innerHTML = '';

            if (!gameData.players) return;

            Object.values(gameData.players).forEach(player => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player-card';
                
                if (player.id === gameData.host_id) {
                    playerDiv.classList.add('host');
                }

                playerDiv.innerHTML = `
                    <div class="player-name">
                        ${player.name}
                        ${player.id === gameData.host_id ? ' üëë' : ''}
                    </div>
                    <div class="player-score">Score: ${player.score || 0}</div>
                `;
                playersList.appendChild(playerDiv);
            });

            // Update scoreboard
            updateScoreboard(gameData);
        }

        function updateScoreboard(gameData) {
            const scoreboardContainer = document.getElementById('scoreboardPlayers');
            const scoreboard = document.getElementById('scoreboard');
            
            if (!gameData.players || gameData.phase === 'waiting') {
                scoreboard.classList.add('hidden');
                return;
            }

            // Show scoreboard during gameplay
            scoreboard.classList.remove('hidden');

            // Sort players by score (highest first)
            const sortedPlayers = Object.values(gameData.players).sort((a, b) => (b.score || 0) - (a.score || 0));

            scoreboardContainer.innerHTML = '';
            sortedPlayers.forEach((player, index) => {
                const scoreDiv = document.createElement('div');
                scoreDiv.className = 'score-player';
                
                if (player.id === gameData.host_id) {
                    scoreDiv.classList.add('host');
                }

                // Add rank indicator for top 3
                let rankIndicator = '';
                if (index === 0 && player.score > 0) rankIndicator = 'ü•á';
                else if (index === 1 && player.score > 0) rankIndicator = 'ü•à';
                else if (index === 2 && player.score > 0) rankIndicator = 'ü•â';

                scoreDiv.innerHTML = `
                    <div class="score-player-name">
                        ${rankIndicator} ${player.name}
                        ${player.id === gameData.host_id ? ' üëë' : ''}
                    </div>
                    <div class="score-player-points">${player.score || 0}</div>
                `;
                scoreboardContainer.appendChild(scoreDiv);
            });
        }

        // Game Logic
        async function joinOrCreateGame() {
            const nameInput = document.getElementById('playerName');
            const codeInput = document.getElementById('gameCode');
            const name = nameInput.value.trim();
            const code = codeInput.value.trim();

            if (!name) {
                showMessage('Please enter your name', 'error');
                return;
            }

            // Validate 4-digit code if provided
            if (code && (!/^\d{4}$/.test(code))) {
                showMessage('Game code must be exactly 4 digits', 'error');
                return;
            }

            currentPlayer.name = name;
            currentPlayer.id = generateId();

            if (code) {
                await joinGame(code);
            } else {
                await createGame();
            }
        }

        async function createGame() {
            const gameCode = generateGameCode();
            currentPlayer.isHost = true;

            const gameData = {
                code: gameCode,
                host_id: currentPlayer.id,
                phase: 'waiting',
                players: {
                    [currentPlayer.id]: {
                        id: currentPlayer.id,
                        name: currentPlayer.name,
                        score: 0
                    }
                },
                black_cards: defaultBlackCards,
                white_cards: defaultWhiteCards,
                round: 0,
                max_rounds: 10,
                created_at: new Date().toISOString()
            };

            try {
                const { error } = await supabase
                    .from('games')
                    .insert([gameData]);

                if (error) throw error;

                currentGame = gameCode;
                setupGameListener(gameCode);
                showGameLobby(gameCode);
                showMessage('Game created successfully!');
            } catch (error) {
                console.error('Error creating game:', error);
                showMessage('Error creating game: ' + error.message, 'error');
            }
        }

        async function joinGame(gameCode) {
            try {
                const { data: gameData, error } = await supabase
                    .from('games')
                    .select('*')
                    .eq('code', gameCode)
                    .single();

                if (error || !gameData) {
                    showMessage('Game not found. Please check the code.', 'error');
                    return;
                }

                if (gameData.phase !== 'waiting') {
                    // Check if this player was already in the game (reconnection)
                    const existingPlayer = Object.values(gameData.players || {}).find(
                        player => player.name === currentPlayer.name
                    );
                    
                    if (existingPlayer) {
                        // Reconnect with same ID and score
                        currentPlayer.id = existingPlayer.id;
                        currentGame = gameCode;
                        setupGameListener(gameCode);
                        showGameLobby(gameCode);
                        showMessage('Reconnected to game!');
                        return;
                    } else {
                        showMessage('This game has already started and you were not a participant.', 'error');
                        return;
                    }
                }

                // Add player to game
                const updatedPlayers = {
                    ...gameData.players,
                    [currentPlayer.id]: {
                        id: currentPlayer.id,
                        name: currentPlayer.name,
                        score: 0
                    }
                };

                const { error: updateError } = await supabase
                    .from('games')
                    .update({ players: updatedPlayers })
                    .eq('code', gameCode);

                if (updateError) throw updateError;

                currentGame = gameCode;
                setupGameListener(gameCode);
                showGameLobby(gameCode);
                showMessage('Joined game successfully!');
            } catch (error) {
                console.error('Error joining game:', error);
                showMessage('Error joining game: ' + error.message, 'error');
            }
        }

        function setupGameListener(gameCode) {
            console.log('Setting up game listener for code:', gameCode);
            
            // Subscribe to real-time updates
            const subscription = supabase
                .channel(`game-${gameCode}`)
                .on('postgres_changes',
                    {
                        event: '*',
                        schema: 'public',
                        table: 'games',
                        filter: `code=eq.${gameCode}`
                    },
                    (payload) => {
                        console.log('Real-time update received:', payload);
                        if (payload.new) {
                            updateGameDisplay(payload.new);
                        }
                    }
                )
                .subscribe((status) => {
                    console.log('Subscription status:', status);
                });

            // Also do periodic polling as backup
            const pollInterval = setInterval(async () => {
                await loadGameData(gameCode);
            }, 3000);

            // Store cleanup function
            window.gameCleanup = () => {
                clearInterval(pollInterval);
                supabase.removeChannel(subscription);
            };

            // Initial load
            loadGameData(gameCode);
        }

        async function loadGameData(gameCode) {
            try {
                const { data: gameData, error } = await supabase
                    .from('games')
                    .select('*')
                    .eq('code', gameCode)
                    .single();

                if (error || !gameData) {
                    console.error('Error loading game data:', error);
                    return;
                }

                updateGameDisplay(gameData);
            } catch (error) {
                console.error('Error loading game data:', error);
            }
        }

        function updateGameDisplay(gameData) {
            updatePlayersDisplay(gameData);

            switch (gameData.phase) {
                case 'waiting':
                    showWaitingPhase(gameData);
                    break;
                default:
                    updateGameStatus('Game in progress...');
                    break;
            }
        }

        function showGameLobby(gameCode) {
            document.getElementById('displayGameCode').textContent = gameCode;
            document.getElementById('mainSection').classList.add('hidden');
            document.getElementById('gameInfoSection').classList.remove('hidden');
            document.getElementById('playersSection').classList.remove('hidden');
            
            if (currentPlayer.isHost) {
                document.getElementById('hostControls').classList.remove('hidden');
            }
        }

        function showWaitingPhase(gameData) {
            updateGameStatus('Waiting for players to join...');
        }

        async function refreshGameData() {
            if (!currentGame) return;
            console.log('Manually refreshing game data for:', currentGame);
            await loadGameData(currentGame);
            showMessage('Player list refreshed!');
        }
            if (!currentPlayer.isHost) return;

            try {
                const { data: gameData, error: fetchError } = await supabase
                    .from('games')
                    .select('*')
                    .eq('code', currentGame)
                    .single();

                if (fetchError) throw fetchError;

                const playerCount = Object.keys(gameData.players).length;

                if (playerCount < 3) {
                    showMessage('Need at least 3 players to start', 'error');
                    return;
                }

                const { error: updateError } = await supabase
                    .from('games')
                    .update({
                        phase: 'playing',
                        round: 1
                    })
                    .eq('code', currentGame);

                if (updateError) throw updateError;

                showMessage('Game started!');
            } catch (error) {
                console.error('Error starting game:', error);
                showMessage('Error starting game: ' + error.message, 'error');
            }
        }

        // Initialize the app
        async function initializeApp() {
            try {
                // Test Supabase connection
                const { data, error } = await supabase.from('games').select('count').limit(1);
                
                if (error) {
                    console.error('Supabase connection error:', error);
                    showMessage('Database connection failed. Please refresh the page.', 'error');
                } else {
                    console.log('Supabase connected successfully');
                    updateGameStatus('Welcome! Enter your name to join or create a game.');
                }
            } catch (error) {
                console.error('Initialization error:', error);
                showMessage('Failed to initialize game. Please refresh the page.', 'error');
            }
        }

        // Event Listeners
        document.getElementById('playerName').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                joinOrCreateGame();
            }
        });

        document.getElementById('gameCode').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                joinOrCreateGame();
            }
        });

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
            
            // Add card counter event listener
            const textarea = document.getElementById('globalBulkCardInput');
            if (textarea) {
                textarea.addEventListener('input', updateCardCounter);
            }
        });
    </script>
</body>
</html>
